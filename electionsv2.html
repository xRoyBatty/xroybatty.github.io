<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polish Presidential Election Vocabulary: Advanced Learning Tool</title>
    <style>
        :root {
            --primary-color: #dc143c; /* Polish Red */
            --secondary-color: #ffffff; /* White */
            --accent-gold: #ffd700; /* Gold for highlights */
            --dark-color: #2c3e50; /* Dark text */
            --light-gray: #f8f9fa; /* Light backgrounds */
            --medium-gray: #6c757d; /* Medium text/borders */
            --success-color: #28a745;
            --error-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #17a2b8;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --border-radius: 12px;
            --shadow-light: 0 2px 8px rgba(0,0,0,0.1);
            --shadow-medium: 0 4px 16px rgba(0,0,0,0.15);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: var(--font-main);
            line-height: 1.6;
            color: var(--dark-color);
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }
        
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        
        .header {
            background: linear-gradient(135deg, var(--primary-color) 0%, #a91c3d 100%);
            color: var(--secondary-color);
            padding: 30px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-medium);
            text-align: center;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .header .subtitle { font-size: 1.2rem; opacity: 0.9; margin-bottom: 20px; }
        
        .nav-tabs { display: flex; justify-content: center; margin-bottom: 30px; background: var(--secondary-color); padding: 8px; border-radius: var(--border-radius); box-shadow: var(--shadow-light); flex-wrap: wrap; }
        .nav-tab { padding: 12px 20px; border: none; background: transparent; color: var(--medium-gray); font-weight: 600; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; margin: 4px; }
        .nav-tab:hover { background: var(--light-gray); color: var(--dark-color); }
        .nav-tab.active { background: var(--primary-color); color: var(--secondary-color); box-shadow: var(--shadow-light); }
        
        .game-section { display: none; animation: fadeIn 0.5s ease-in-out; }
        .game-section.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        
        .stats-panel { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .stat-card { background: var(--secondary-color); padding: 20px; border-radius: var(--border-radius); box-shadow: var(--shadow-light); text-align: center; transition: transform 0.3s ease; }
        .stat-card:hover { transform: translateY(-5px); }
        .stat-value { font-size: 2rem; font-weight: bold; color: var(--primary-color); margin-bottom: 5px; }
        .stat-label { color: var(--medium-gray); font-size: 0.9rem; }

        /* Matching Mode - Restored Styles */
        .matching-container { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px; }
        .terms-panel, .definitions-panel { background: var(--secondary-color); padding: 25px; border-radius: var(--border-radius); box-shadow: var(--shadow-light); }
        .panel-header { font-size: 1.3rem; font-weight: bold; color: var(--primary-color); margin-bottom: 20px; padding-bottom: 10px; border-bottom: 3px solid var(--primary-color); display: flex; align-items: center; justify-content: space-between; }
        .panel-header::after { content: "Click to select"; font-size: 0.8rem; color: var(--medium-gray); font-weight: normal; font-style: italic; }
        .panel-icon { font-size: 1.5rem; }

        .term-item { background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border: 2px solid transparent; border-radius: var(--border-radius); padding: 15px; margin-bottom: 12px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: space-between; min-height: 70px; position: relative; user-select: none; }
        .term-item:hover { transform: translateX(5px); box-shadow: var(--shadow-medium); border-color: var(--primary-color); }
        .term-item.selected { background: linear-gradient(135deg, rgba(220, 20, 60, 0.1) 0%, rgba(220, 20, 60, 0.2) 100%); border-color: var(--primary-color); box-shadow: var(--shadow-medium); }
        .term-item.matched { background: linear-gradient(135deg, var(--success-color) 0%, #20c997 100%) !important; color: white !important; border-color: var(--success-color) !important; }
        .term-item.matched.incorrect-match { background: linear-gradient(135deg, var(--error-color) 0%, #c82333 100%) !important; border-color: var(--error-color) !important; }


        .term-content { display: flex; align-items: center; flex: 1; }
        .term-number { background: var(--primary-color); color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 15px; flex-shrink: 0; }
        .term-text { flex: 1; }
        .term-english { font-weight: 600; margin-bottom: 3px; }
        
        .audio-btn { padding: 8px; background: var(--info-color); color: white; border: none; border-radius: 50%; cursor: pointer; transition: all 0.3s ease; margin-left: 10px; width: 35px; height: 35px; display: inline-flex; align-items: center; justify-content: center; font-size: 1rem; }
        .audio-btn:hover { background: #138496; transform: scale(1.1); }
        
        .match-indicator { width: 35px; height: 35px; border: 2px solid var(--primary-color); border-radius: 6px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1.1rem; color: var(--primary-color); margin-left: 10px; background: white; cursor: pointer; transition: all 0.3s ease; }
        .match-indicator:hover { background: var(--light-gray); transform: scale(1.05); }
        .match-indicator.filled { background: var(--primary-color); color: white; }
        
        .definition-item { background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border: 2px solid #dee2e6; border-radius: var(--border-radius); padding: 20px; margin-bottom: 12px; min-height: 70px; display: flex; align-items: center; transition: all 0.3s ease; position: relative; cursor: pointer; }
        .definition-item:hover { border-color: var(--primary-color); background: rgba(220, 20, 60, 0.05); transform: translateX(-5px); box-shadow: var(--shadow-medium); }
        .definition-item.selected { border-color: var(--primary-color); background: linear-gradient(135deg, rgba(220, 20, 60, 0.1) 0%, rgba(220, 20, 60, 0.2) 100%); box-shadow: var(--shadow-medium); }
        .definition-item.matched { border-color: var(--success-color) !important; background: linear-gradient(135deg, rgba(40, 167, 69, 0.1) 0%, rgba(32, 201, 151, 0.1) 100%) !important; }
        .definition-item.matched.incorrect-match { background: linear-gradient(135deg, rgba(220,53,69,0.1) 0%, rgba(200,35,51,0.1) 100%) !important; border-color: var(--error-color) !important; }

        .definition-letter { background: var(--dark-color); color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 15px; flex-shrink: 0; }
        .definition-text { flex: 1; line-height: 1.5; }
        .results-panel { background: var(--secondary-color); padding: 30px; border-radius: var(--border-radius); box-shadow: var(--shadow-light); margin: 30px 0; text-align: center; display: none; }
        .results-panel.show { display: block; animation: slideUp 0.5s ease-out; }
        @keyframes slideUp { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
        .score-display { font-size: 3rem; font-weight: bold; color: var(--primary-color); margin-bottom: 15px; }


        .flashcard-container { max-width: 600px; margin: 20px auto; perspective: 1000px; }
        .flashcard { background: var(--secondary-color); border-radius: var(--border-radius); box-shadow: var(--shadow-medium); min-height: 300px; position: relative; transform-style: preserve-3d; transition: transform 0.6s ease; cursor: pointer; }
        .flashcard.flipped { transform: rotateY(180deg); }
        .flashcard-front, .flashcard-back { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; flex-direction:column; align-items: center; justify-content: center; text-align: center; padding: 20px; border-radius: var(--border-radius); }
        .flashcard-back { transform: rotateY(180deg); background: linear-gradient(135deg, var(--primary-color) 0%, #a91c3d 100%); color: white; }
        .flashcard-term { font-size: 1.8rem; font-weight: bold; margin-bottom: 15px; }
        .flashcard-definition { font-size: 1.1rem; line-height: 1.5; }

        .quiz-container { max-width: 800px; margin: 0 auto; }
        .question-card { background: var(--secondary-color); padding: 30px; border-radius: var(--border-radius); box-shadow: var(--shadow-light); margin-bottom: 30px; }
        .question-text { font-size: 1.3rem; font-weight: 600; margin-bottom: 25px; }
        .options-list { list-style: none; }
        .option-item { background: var(--light-gray); border: 2px solid transparent; border-radius: var(--border-radius); padding: 15px 20px; margin-bottom: 10px; cursor: pointer; transition: all 0.3s ease; }
        .option-item:hover { background: #e9ecef; border-color: var(--primary-color); }
        .option-item.selected { background: rgba(220, 20, 60, 0.1); border-color: var(--primary-color); }
        .option-item.correct { background: rgba(40, 167, 69, 0.2) !important; border-color: var(--success-color) !important; }
        .option-item.incorrect { background: rgba(220, 53, 69, 0.2) !important; border-color: var(--error-color) !important; }


        .controls { display: flex; justify-content: center; flex-wrap: wrap; gap: 15px; margin: 30px 0; }
        .btn { padding: 12px 24px; border: none; border-radius: var(--border-radius); font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
        .btn-primary { background: linear-gradient(135deg, var(--primary-color) 0%, #a91c3d 100%); color: white; }
        .btn-secondary { background: linear-gradient(135deg, var(--medium-gray) 0%, #5a6268 100%); color: white; }
        .btn-success { background: linear-gradient(135deg, var(--success-color) 0%, #20c997 100%); color: white; }
        .btn-danger { background: linear-gradient(135deg, var(--error-color) 0%, #c82333 100%); color: white; }
        .btn-warning { background: linear-gradient(135deg, var(--warning-color) 0%, #e0a800 100%); color: var(--dark-color); }
        .btn-info { background: linear-gradient(135deg, var(--info-color) 0%, #138496 100%); color: white; }
        .btn:hover { transform: translateY(-2px); box-shadow: var(--shadow-medium); }
        
        .form-control { width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-radius: var(--border-radius); font-size: 1rem; }

        .progress-container { background: var(--secondary-color); padding: 20px; border-radius: var(--border-radius); box-shadow: var(--shadow-light); margin-bottom: 30px; }
        .progress-bar { width: 100%; height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden; margin-bottom: 10px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--primary-color) 0%, #a91c3d 100%); transition: width 0.5s ease; }
        .progress-text { text-align: center; color: var(--medium-gray); font-size: 0.9rem; }

        #srs-mode .flashcard-container { margin-bottom: 20px; }
        #srs-mode .flashcard-front, #srs-mode .flashcard-back { display:flex; flex-direction:column; align-items:center; justify-content:center; }
        #srs-mode .flashcard-term { font-size: 1.5em; }
        #srs-mode .flashcard-definition { font-size: 1em; }
        #srs-mode .srs-pre-assessment-controls button { margin: 0 10px; }
        #srs-mode .question-card { margin-top: 20px; }
        #srsFeedback { min-height: 2em; font-weight: bold; }

        .srs-settings-panel {
            background: var(--secondary-color);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-light);
            margin: 20px auto;
            max-width: 600px;
        }
        .srs-settings-panel h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            text-align: center;
        }
        .srs-settings-panel .setting-group {
            margin-bottom: 15px;
        }
        .srs-settings-panel label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        .srs-settings-panel input[type="checkbox"], .srs-settings-panel input[type="number"] {
            margin-right: 8px;
        }
        .srs-settings-panel input[type="number"] {
            width: 70px;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid var(--medium-gray);
        }


        @media (max-width: 768px) {
            .container { padding: 15px; }
            .header h1 { font-size: 2rem; }
            .matching-container { grid-template-columns: 1fr; gap: 20px; }
            .nav-tab { padding: 10px 12px; font-size: 0.9rem;}
            .stats-panel { grid-template-columns: 1fr 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Polish Presidential Election Vocabulary</h1>
            <div class="subtitle">Master Essential Terms with Advanced Learning Techniques</div>
        </header>
        
        <div class="stats-panel">
            <div class="stat-card">
                <div class="stat-value" id="totalTermsDisplay">15</div>
                <div class="stat-label">Total Terms</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="masteredTermsDisplay">0</div>
                <div class="stat-label">Mastered (SRS)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="learningTermsDisplay">0</div>
                <div class="stat-label">Learning (SRS)</div>
            </div>
             <div class="stat-card">
                <div class="stat-value" id="dueTodayDisplay">0</div>
                <div class="stat-label">Due Today (SRS)</div>
            </div>
        </div>
        
        <nav class="nav-tabs">
            <button class="nav-tab active" onclick="switchMode('matching')">Matching</button>
            <button class="nav-tab" onclick="switchMode('flashcards')">Flashcards</button>
            <button class="nav-tab" onclick="switchMode('quiz')">Multiple Choice</button>
            <button class="nav-tab" onclick="switchMode('study')">Study Guide</button>
            <button class="nav-tab" onclick="switchMode('srs')">SRS Learn</button>
        </nav>
        
        <!-- Matching Mode -->
        <div class="game-section active" id="matching-mode">
            <div class="progress-container">
                <div class="progress-bar"><div class="progress-fill" id="matchingProgress" style="width: 0%"></div></div>
                <div class="progress-text"><span id="matchedCountDisplay">0</span> of <span id="totalMatchCountDisplay">15</span> terms matched</div>
            </div>
            <div class="matching-container">
                <div class="terms-panel">
                    <div class="panel-header"><span>Terms</span><span class="panel-icon">📝</span></div>
                    <div class="terms-list" id="termsList"></div>
                </div>
                <div class="definitions-panel">
                    <div class="panel-header"><span>Definitions</span><span class="panel-icon">📖</span></div>
                    <div class="definitions-list" id="definitionsList"></div>
                </div>
            </div>
            <div class="controls">
                <button class="btn btn-primary" onclick="checkMatchingAnswers()">Check Matches</button>
                <button class="btn btn-secondary" onclick="resetMatching()">Reset</button>
            </div>
            <div class="results-panel" id="matchingResultsPanel">
                <div class="score-display" id="matchingScoreDisplay">0/15</div>
                <p id="matchingFeedbackText"></p>
            </div>
        </div>
        
        <!-- Flashcard Mode -->
        <div class="game-section" id="flashcards-mode">
            <div class="progress-container">
                <div class="progress-bar"><div class="progress-fill" id="flashcardProgress" style="width: 0%"></div></div>
                <div class="progress-text">Card <span id="currentCardDisplay">1</span> of <span id="totalCardsDisplay">15</span></div>
            </div>
            <div class="flashcard-container">
                <div class="flashcard" id="flashcard" onclick="flipCard()">
                    <div class="flashcard-front">
                        <div class="flashcard-content">
                             <div class="flashcard-term" id="flashcardTerm"></div>
                             <button class="audio-btn" id="flashcardAudioBtn" onclick="playAudio('', event)">🔊</button>
                        </div>
                    </div>
                    <div class="flashcard-back">
                         <div class="flashcard-content">
                            <div class="flashcard-definition" id="flashcardDefinition"></div>
                         </div>
                    </div>
                </div>
            </div>
            <div class="flashcard-controls controls">
                <button class="btn btn-secondary" onclick="previousCard()">← Previous</button>
                <button class="btn btn-primary" onclick="flipCard()">Flip Card</button>
                <button class="btn btn-secondary" onclick="nextCard()">Next →</button>
            </div>
        </div>
        
        <!-- Quiz Mode -->
        <div class="game-section" id="quiz-mode">
            <div class="progress-container">
                <div class="progress-bar"><div class="progress-fill" id="quizProgress" style="width: 0%"></div></div>
                <div class="progress-text">Question <span id="currentQuestionDisplay">1</span> of <span id="totalQuestionsDisplay">15</span></div>
            </div>
            <div class="quiz-container">
                <div class="question-card">
                    <div class="question-text" id="questionText">Select the correct definition for: <strong id="questionTerm">Term</strong></div>
                    <ul class="options-list" id="optionsList"></ul>
                </div>
                <div class="controls">
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuizAnswer()">Submit Answer</button>
                    <button class="btn btn-secondary" id="nextQuizBtn" onclick="nextQuizQuestion()" style="display:none;">Next Question</button>
                </div>
            </div>
        </div>
        
        <!-- Study Guide Mode -->
        <div class="game-section" id="study-mode">
            <div class="quiz-container">
                <div class="question-card">
                    <h2 style="color: var(--primary-color); margin-bottom: 20px;">Complete Study Guide</h2>
                    <div id="studyContent"></div>
                </div>
            </div>
        </div>

        <!-- SRS Learn Mode -->
        <div class="game-section" id="srs-mode">
            <div class="srs-settings-panel">
                <h3>SRS Learning Settings</h3>
                <div class="setting-group">
                    <label>Question Types:</label>
                    <input type="checkbox" id="srsUseWriting" checked> <label for="srsUseWriting" style="display:inline;">Writing</label>
                    <input type="checkbox" id="srsUseMC" checked> <label for="srsUseMC" style="display:inline;">Multiple Choice</label>
                    <input type="checkbox" id="srsUseTF" checked> <label for="srsUseTF" style="display:inline;">True/False</label>
                </div>
                <div class="setting-group">
                    <label for="srsSessionSize">Terms per session:</label>
                    <input type="number" id="srsSessionSize" value="10" min="3" max="20">
                </div>
                <button class="btn btn-primary" onclick="applySRSSettingsAndStart()">Start/Restart SRS Session</button>
            </div>
            <div id="srsSessionArea" class="quiz-container" style="margin-top:20px;">
                <!-- SRS cards will be rendered here -->
            </div>
             <div class="progress-container" style="margin-top: 20px;">
                <div class="progress-bar"><div class="progress-fill" id="srsProgressFill" style="width: 0%"></div></div>
                <div class="progress-text" id="srsProgressText">Session not started.</div>
            </div>
        </div>

    </div>
    
    <script>
        // --- DATA ---
        const vocabularyData = [
            // ... (Vocabulary data remains the same as your last provided version with bracketed Polish and examples)
             {
                id: 1, english: "Term of Office", polish: "Kadencja",
                definition: "The 5-year period during which the Polish president serves in office",
                pronunciation: "TURM uhv AW-fis",
                exampleEnglish: "The President is elected for a five-year term of office.",
                examplePolish: "Prezydent jest wybierany na pięcioletnią kadencję."
            },
            {
                id: 2, english: "Polling Station", polish: "Lokal Wyborczy",
                definition: "The designated place where Polish voters go to cast their ballots during presidential elections",
                pronunciation: "POH-ling STAY-shuhn",
                exampleEnglish: "Voters queued outside the polling station early in the morning.",
                examplePolish: "Wyborcy ustawiali się w kolejce przed lokalem wyborczym wcześnie rano."
            },
            {
                id: 3, english: "Presidential Candidate", polish: "Kandydat na Prezydenta",
                definition: "A person running for the office of President of the Republic of Poland",
                pronunciation: "prez-i-DEN-shuhl KAN-di-dayt",
                exampleEnglish: "Each presidential candidate presented their program to the nation.",
                examplePolish: "Każdy kandydat na prezydenta przedstawił swój program narodowi."
            },
            {
                id: 4, english: "Voter Turnout", polish: "Frekwencja Wyborcza",
                definition: "The percentage of eligible (uprawnionych) voters who participate in Polish presidential elections",
                pronunciation: "VOH-ter TURN-owt",
                exampleEnglish: "High voter turnout is often seen as a sign of a healthy democracy.",
                examplePolish: "Wysoka frekwencja wyborcza jest często postrzegana jako oznaka zdrowej demokracji."
            },
            {
                id: 5, english: "Two-Round System", polish: "System Dwuturowy",
                definition: "Poland's electoral system where a second round is held (odbywana) if no candidate gets over 50% in the first round",
                pronunciation: "TOO-rownd SIS-tuhm",
                exampleEnglish: "If no candidate wins a majority, the election goes to a two-round system.",
                examplePolish: "Jeśli żaden kandydat nie zdobędzie większości, wybory przechodzą do systemu dwuturowego."
            },
            {
                id: 6, english: "Voting Booth", polish: "Kabina do Głosowania",
                definition: "The private enclosed space where Polish voters mark their ballots in secret",
                pronunciation: "VOH-ting BOOTH",
                exampleEnglish: "Each voter entered the voting booth to mark their ballot privately.",
                examplePolish: "Każdy wyborca wszedł do kabiny do głosowania, aby prywatnie zaznaczyć swoją kartę."
            },
            {
                id: 7, english: "Ballot Box", polish: "Urna Wyborcza",
                definition: "The secure container where completed ballots are deposited during Polish elections",
                pronunciation: "BAL-uht BOKS",
                exampleEnglish: "After voting, citizens placed their folded ballots into the ballot box.",
                examplePolish: "Po zagłosowaniu obywatele wkładali złożone karty do głosowania do urny wyborczej."
            },
            {
                id: 8, english: "Cast a Vote", polish: "Oddać Głos",
                definition: "The act of submitting your completed ballot in Polish elections",
                pronunciation: "KAST uh VOHT",
                exampleEnglish: "Every eligible citizen has the right to cast a vote.",
                examplePolish: "Każdy uprawniony obywatel ma prawo oddać głos."
            },
            {
                id: 9, english: "Ballot Paper", polish: "Karta do Głosowania",
                definition: "The official document listing presidential candidates in Polish elections",
                pronunciation: "BAL-uht PAY-per",
                exampleEnglish: "The ballot paper listed all candidates in alphabetical order.",
                examplePolish: "Karta do głosowania wymieniała wszystkich kandydatów w kolejności alfabetycznej."
            },
            {
                id: 10, english: "Commander-in-Chief", polish: "Naczelny Dowódca",
                definition: "Constitutional role of the Polish President as head of the Polish Armed Forces",
                pronunciation: "kuh-MAN-der in CHEEF",
                exampleEnglish: "The President, as Commander-in-Chief, has authority over the military.",
                examplePolish: "Prezydent, jako Naczelny Dowódca, ma władzę nad wojskiem."
            },
            {
                id: 11, english: "Election Silence", polish: "Cisza Wyborcza",
                definition: "48-hour period before Polish elections when campaigning and publishing polls is prohibited",
                pronunciation: "i-LEK-shuhn SAY-luhns",
                exampleEnglish: "Election silence begins two days before polling day.",
                examplePolish: "Cisza wyborcza rozpoczyna się dwa dni przed dniem głosowania."
            },
            {
                id: 12, english: "Presidential Pardon", polish: "Ułaskawienie Prezydenckie",
                definition: "The Polish President's constitutional power to grant pardons, except for those convicted (skazanych) by the State Tribunal",
                pronunciation: "prez-i-DEN-shuhl PAR-duhn",
                exampleEnglish: "The President has the authority to issue a presidential pardon.",
                examplePolish: "Prezydent ma prawo wydać ułaskawienie prezydenckie."
            },
            {
                id: 13, english: "Campaign Spot", polish: "Spot Wyborczy",
                definition: "Political advertisement broadcast (nadawany) during Polish presidential election campaigns",
                pronunciation: "kam-PAYN SPOT",
                exampleEnglish: "Each party produced a compelling campaign spot for television.",
                examplePolish: "Każda partia wyprodukowała przekonujący spot wyborczy do telewizji."
            },
            {
                id: 14, english: "Presidential Oath", polish: "Przysięga Prezydencka",
                definition: "Solemn (uroczysty) oath taken by the Polish President before the National Assembly (Zgromadzenie Narodowe) when assuming office (obejmując urząd)",
                pronunciation: "prez-i-DEN-shuhl OHTH",
                exampleEnglish: "The new president took the presidential oath at the parliament.",
                examplePolish: "Nowy prezydent złożył przysięgę prezydencką w parlamencie."
            },
            {
                id: 15, english: "Cabinet Council", polish: "Rada Gabinetowa",
                definition: "Special advisory body consisting of the Council of Ministers under the Polish President's chairmanship (przewodnictwem)",
                pronunciation: "KAB-i-nuht KOWN-suhl",
                exampleEnglish: "The President convened the Cabinet Council to discuss urgent matters.",
                examplePolish: "Prezydent zwołał Radę Gabinetową, aby omówić pilne sprawy."
            }
        ];

        // --- GLOBAL STATE & UTILITIES ---
        let currentMode = 'matching';
        let srsDataGlobal; 
        const SRS_DATA_KEY = 'polishVocabSRSData_v3'; // Incremented version for any structural changes
        const SRS_LEVEL_INTERVALS = [1, 2, 5, 10, 20, 45, 90]; 

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function playAudio(text, event) { // Removed lang parameter
            if (event) event.stopPropagation();
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US'; // Default to English
                utterance.rate = 0.9;
                utterance.pitch = 1;
                utterance.volume = 0.9;
                speechSynthesis.speak(utterance);
            } else {
                console.warn("Speech synthesis not supported.");
            }
        }

        // --- SRS DATA MANAGEMENT (remains largely the same) ---
        function loadSRSData() {
            try {
                const data = localStorage.getItem(SRS_DATA_KEY);
                if (data) {
                    const parsedData = JSON.parse(data);
                    if (parsedData.termsProgress && parsedData.srsSettings && parsedData.srsSettings.sessionSize) {
                        return parsedData;
                    }
                }
            } catch (error) { console.error("Error loading SRS data:", error); }
            return {
                termsProgress: {},
                srsSettings: { useWriting: true, useMultipleChoice: true, useTrueFalse: true, sessionSize: 10 },
                lastSessionDate: new Date().toISOString()
            };
        }
        function saveSRSData() { 
            try {
                srsDataGlobal.lastSessionDate = new Date().toISOString();
                localStorage.setItem(SRS_DATA_KEY, JSON.stringify(srsDataGlobal));
            } catch (error) { console.error("Error saving SRS data:", error); }
        }
        function initializeTermProgress(termId) {
            if (!srsDataGlobal.termsProgress[termId]) {
                srsDataGlobal.termsProgress[termId] = {
                    masteryLevel: 0, dueDate: new Date().toISOString(), history: [], 
                    srsStage: 'new', lastReviewed: null
                };
            }
        }
        
        // --- SRS LOGIC (remains largely the same) ---
        function getSRSDueTerms(maxCount) {
            const dueTerms = [];
            const today = new Date();
            const shuffledVocab = [...vocabularyData].sort(() => Math.random() - 0.5);
            for (const term of shuffledVocab) {
                const progress = srsDataGlobal.termsProgress[term.id];
                if (!progress) initializeTermProgress(term.id); 
                const dueDate = new Date(progress.dueDate);
                if (dueDate <= today) { dueTerms.push(term); }
            }
            dueTerms.sort((a, b) => {
                const progA = srsDataGlobal.termsProgress[a.id];
                const progB = srsDataGlobal.termsProgress[b.id];
                const dateDiff = new Date(progA.dueDate) - new Date(progB.dueDate);
                if (dateDiff !== 0) return dateDiff;
                return progA.masteryLevel - progB.masteryLevel;
            });
            return dueTerms.slice(0, maxCount);
        }
        function updateSRSTerm(termId, outcome, quizType = 'pre-assessment') {
            const progress = srsDataGlobal.termsProgress[termId];
            const now = new Date();
            progress.lastReviewed = now.toISOString();
            progress.history.push({ date: now.toISOString(), action: outcome, quizType });

            if (outcome === 'know' || outcome === 'correct') {
                progress.masteryLevel = Math.min(progress.masteryLevel + 1, SRS_LEVEL_INTERVALS.length - 1);
            } else if (outcome === 'dont_know' || outcome === 'incorrect') {
                progress.masteryLevel = Math.max(0, progress.masteryLevel - 2); 
            } else if (outcome === 'practicing') {
                progress.masteryLevel = Math.max(0, progress.masteryLevel -1); 
            }
            
            if (progress.masteryLevel === 0) progress.srsStage = 'learning';
            else if (progress.masteryLevel >= SRS_LEVEL_INTERVALS.length -1) progress.srsStage = 'mastered';
            else progress.srsStage = 'review';
            
            const intervalDays = SRS_LEVEL_INTERVALS[progress.masteryLevel];
            const nextDueDate = new Date(); 
            nextDueDate.setDate(now.getDate() + intervalDays);
            progress.dueDate = nextDueDate.toISOString();
            
            saveSRSData();
            updateOverallStatsDisplay(); 
        }

        // --- UI & MODE MANAGEMENT ---
        document.addEventListener('DOMContentLoaded', function() {
            srsDataGlobal = loadSRSData();
            vocabularyData.forEach(term => initializeTermProgress(term.id)); 
            saveSRSData(); 

            switchMode(currentMode); 
            updateOverallStatsDisplay(); 
            
            document.getElementById('srsUseWriting').checked = srsDataGlobal.srsSettings.useWriting;
            document.getElementById('srsUseMC').checked = srsDataGlobal.srsSettings.useMultipleChoice;
            document.getElementById('srsUseTF').checked = srsDataGlobal.srsSettings.useTrueFalse;
            document.getElementById('srsSessionSize').value = srsDataGlobal.srsSettings.sessionSize;
        });

        function switchMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`.nav-tab[onclick="switchMode('${mode}')"]`).classList.add('active');
            document.querySelectorAll('.game-section').forEach(section => section.classList.remove('active'));
            document.getElementById(mode + '-mode').classList.add('active');

            if (mode === 'matching') initializeMatching();
            else if (mode === 'flashcards') initializeFlashcards();
            else if (mode === 'quiz') initializeQuiz();
            else if (mode === 'study') initializeStudyGuide();
            else if (mode === 'srs') { 
                document.getElementById('srsSessionArea').innerHTML = "<p style='text-align:center; padding:15px;'>Configure settings above and click 'Start/Restart SRS Session'.</p>"; 
                updateSRSProgressText("Session not started.");
            }
            updateOverallStatsDisplay();
        }
        
        function updateOverallStatsDisplay() {
            document.getElementById('totalTermsDisplay').textContent = vocabularyData.length;
            let masteredCount = 0;
            let learningCount = 0; 
            let dueTodayCount = 0;
            const today = new Date();
            today.setHours(0,0,0,0); 

            Object.values(srsDataGlobal.termsProgress).forEach(p => {
                if (p.srsStage === 'mastered' && new Date(p.dueDate) > today) { 
                     masteredCount++;
                } else {
                    learningCount++; 
                }
                if (new Date(p.dueDate) <= new Date(new Date().setDate(today.getDate()))) { 
                    dueTodayCount++;
                }
            });
            document.getElementById('masteredTermsDisplay').textContent = masteredCount;
            document.getElementById('learningTermsDisplay').textContent = learningCount;
            document.getElementById('dueTodayDisplay').textContent = dueTodayCount;
        }

        // --- MATCHING MODE (Restored UI Logic) ---
        let matchingSelectedTerm = null;
        let matchingSelectedDef = null;
        let matchingUserAnswers = {}; // termId: definitionLetter

        function initializeMatching() {
            const termsList = document.getElementById('termsList');
            const definitionsList = document.getElementById('definitionsList');
            termsList.innerHTML = ''; definitionsList.innerHTML = '';
            
            const shuffledTerms = [...vocabularyData]; shuffleArray(shuffledTerms);
            const shuffledDefinitions = [...vocabularyData]; shuffleArray(shuffledDefinitions);

            shuffledTerms.forEach((term, index) => {
                const termElement = createMatchingTermElement(term, index + 1);
                termsList.appendChild(termElement);
            });
            
            shuffledDefinitions.forEach((term, index) => {
                const definitionElement = createMatchingDefinitionElement(term, String.fromCharCode(65 + index));
                definitionsList.appendChild(definitionElement);
            });
            
            matchingUserAnswers = {};
            matchingSelectedTerm = null;
            matchingSelectedDef = null;
            document.getElementById('matchingResultsPanel').classList.remove('show');
            updateMatchingProgressDisplay();
        }

        function createMatchingTermElement(term, displayNumber) {
            const div = document.createElement('div');
            div.className = 'term-item';
            div.dataset.termId = term.id;
            div.dataset.type = 'term'; // Keep type for handler
            
            div.innerHTML = `
                <div class="term-content">
                    <div class="term-number">${displayNumber}</div>
                    <div class="term-text">
                        <div class="term-english">${term.english}</div>
                    </div>
                </div>
                <div class="match-indicator" data-term-id="${term.id}"></div>
                <button class="audio-btn" onclick="playAudio('${term.english}', event)">🔊</button>
            `;
            div.addEventListener('click', handleMatchingItemClick);
            return div;
        }

        function createMatchingDefinitionElement(term, letter) {
            const div = document.createElement('div');
            div.className = 'definition-item';
            div.dataset.termId = term.id; // Actual ID of the term this definition belongs to
            div.dataset.letter = letter; // Display letter
            div.dataset.type = 'definition'; // Keep type for handler
            
            div.innerHTML = `
                <div class="definition-letter">${letter}</div>
                <div class="definition-text">${term.definition}</div>
            `;
            div.addEventListener('click', handleMatchingItemClick);
            return div;
        }

        function handleMatchingItemClick(e) {
            const clickedItem = e.currentTarget;
            const clickedId = clickedItem.dataset.termId;
            const clickedType = clickedItem.dataset.type;

            if (e.target.classList.contains('audio-btn') || e.target.closest('.audio-btn')) {
                return; // Don't process clicks on audio buttons for matching logic
            }
             // If clicking on a match indicator of an already matched term, unmatch it
            if (e.target.classList.contains('match-indicator') && e.target.classList.contains('filled')) {
                const termIdToUnmatch = e.target.dataset.termId;
                unmatchPair(termIdToUnmatch);
                return;
            }

            if (clickedItem.classList.contains('matched')) return; // Don't re-select already processed items

            if (clickedType === 'term') {
                if (matchingSelectedTerm) matchingSelectedTerm.classList.remove('selected');
                matchingSelectedTerm = clickedItem;
                matchingSelectedTerm.classList.add('selected');
            } else if (clickedType === 'definition') {
                if (matchingSelectedDef) matchingSelectedDef.classList.remove('selected');
                matchingSelectedDef = clickedItem;
                matchingSelectedDef.classList.add('selected');
            }

            if (matchingSelectedTerm && matchingSelectedDef) {
                const termId = matchingSelectedTerm.dataset.termId;
                const defLetter = matchingSelectedDef.dataset.letter;
                const defIdForPairing = matchingSelectedDef.dataset.termId; // The ID of the term this definition actually belongs to

                // Store the user's choice: termId maps to the letter of the chosen definition
                matchingUserAnswers[termId] = { letter: defLetter, chosenDefId: defIdForPairing };

                // Update UI for the term
                const indicator = matchingSelectedTerm.querySelector('.match-indicator');
                indicator.textContent = defLetter;
                indicator.classList.add('filled');
                
                // Mark both as "processed" for this attempt (not necessarily "correct")
                // We will add 'matched' and 'incorrect-match' upon checking answers
                matchingSelectedTerm.classList.add('temp-matched'); 
                matchingSelectedDef.classList.add('temp-matched');


                // Clear selections
                matchingSelectedTerm.classList.remove('selected');
                matchingSelectedDef.classList.remove('selected');
                matchingSelectedTerm = null;
                matchingSelectedDef = null;
                updateMatchingProgressDisplay();
            }
        }
        
        function unmatchPair(termIdToUnmatch) {
            const termItem = document.querySelector(`.term-item[data-term-id="${termIdToUnmatch}"]`);
            if (!termItem) return;

            const previousAnswer = matchingUserAnswers[termIdToUnmatch];
            if (previousAnswer) {
                const defItem = document.querySelector(`.definition-item[data-letter="${previousAnswer.letter}"]`);
                if (defItem) {
                    defItem.classList.remove('temp-matched', 'matched', 'incorrect-match', 'selected');
                    defItem.style.borderColor = ''; // Reset border
                }
            }

            termItem.classList.remove('temp-matched', 'matched', 'incorrect-match', 'selected');
            termItem.style.borderColor = ''; // Reset border
            const indicator = termItem.querySelector('.match-indicator');
            indicator.textContent = '';
            indicator.classList.remove('filled');
            
            delete matchingUserAnswers[termIdToUnmatch];
            updateMatchingProgressDisplay();
        }


        function updateMatchingProgressDisplay() {
            const count = Object.keys(matchingUserAnswers).length;
            document.getElementById('matchedCountDisplay').textContent = count;
            document.getElementById('totalMatchCountDisplay').textContent = vocabularyData.length;
            document.getElementById('matchingProgress').style.width = (count / vocabularyData.length * 100) + '%';
        }

        function checkMatchingAnswers() {
            let correctCount = 0;
            document.querySelectorAll('.term-item, .definition-item').forEach(el => {
                el.classList.remove('matched', 'incorrect-match'); // Clear previous validation states
                el.style.borderColor = ''; // Reset borders
            });

            for (const termId in matchingUserAnswers) {
                const userAnswer = matchingUserAnswers[termId]; // { letter, chosenDefId }
                const termItem = document.querySelector(`.term-item[data-term-id="${termId}"]`);
                const defItem = document.querySelector(`.definition-item[data-letter="${userAnswer.letter}"]`);

                if (termItem && defItem) {
                    if (termId === userAnswer.chosenDefId) { // Correct match
                        correctCount++;
                        termItem.classList.add('matched');
                        defItem.classList.add('matched');
                    } else { // Incorrect match
                        termItem.classList.add('incorrect-match');
                        defItem.classList.add('incorrect-match');
                    }
                }
            }
            
            const resultsPanel = document.getElementById('matchingResultsPanel');
            document.getElementById('matchingScoreDisplay').textContent = `${correctCount}/${vocabularyData.length}`;
            document.getElementById('matchingFeedbackText').textContent = correctCount === vocabularyData.length ? "Perfect! All matched correctly! 🎉" : "Some matches are incorrect. Review the highlighted items.";
            resultsPanel.classList.add('show');
        }

        function resetMatching() {
            document.querySelectorAll('.term-item, .definition-item').forEach(el => {
                el.classList.remove('selected', 'matched', 'incorrect-match', 'temp-matched');
                el.style.borderColor = ''; // Reset border
                const indicator = el.querySelector && el.querySelector('.match-indicator');
                if (indicator) {
                    indicator.textContent = '';
                    indicator.classList.remove('filled');
                }
            });
            initializeMatching(); // This will re-shuffle and clear userAnswers
        }


        // --- FLASHCARD MODE ---
        let currentFlashcardIndex = 0;
        function initializeFlashcards() { 
            currentFlashcardIndex = 0;
            shuffleArray(vocabularyData); 
            updateFlashcardDisplay();
        }
        function updateFlashcardDisplay() {
            if (vocabularyData.length === 0) return;
            const term = vocabularyData[currentFlashcardIndex];
            document.getElementById('flashcardTerm').textContent = term.english;
            document.getElementById('flashcardAudioBtn').onclick = (event) => playAudio(term.english, event);
            document.getElementById('flashcardDefinition').innerHTML = `<strong>${term.polish}</strong><br><br>${term.definition}`;
            document.getElementById('flashcard').classList.remove('flipped');
            document.getElementById('currentCardDisplay').textContent = currentFlashcardIndex + 1;
            document.getElementById('totalCardsDisplay').textContent = vocabularyData.length;
            document.getElementById('flashcardProgress').style.width = ((currentFlashcardIndex + 1) / vocabularyData.length * 100) + '%';
        }
        function flipCard() { document.getElementById('flashcard').classList.toggle('flipped'); }
        function nextCard() { currentFlashcardIndex = (currentFlashcardIndex + 1) % vocabularyData.length; updateFlashcardDisplay(); }
        function previousCard() { currentFlashcardIndex = (currentFlashcardIndex - 1 + vocabularyData.length) % vocabularyData.length; updateFlashcardDisplay(); }

        // --- QUIZ MODE (Standard Multiple Choice) ---
        let currentQuizTermIndex = 0;
        let quizShuffledTerms = [];
        function initializeQuiz() { 
            quizShuffledTerms = [...vocabularyData];
            shuffleArray(quizShuffledTerms);
            currentQuizTermIndex = 0;
            displayQuizQuestion();
        }
        function displayQuizQuestion() {
            const submitBtn = document.getElementById('submitQuizBtn');
            const nextBtn = document.getElementById('nextQuizBtn');
            
            if (currentQuizTermIndex >= quizShuffledTerms.length) {
                document.getElementById('questionText').innerHTML = `Quiz Complete! Score: ${document.querySelectorAll('#optionsList .option-item.correct').length}/${quizShuffledTerms.length}`;
                document.getElementById('optionsList').innerHTML = '';
                submitBtn.style.display = 'none';
                nextBtn.textContent = 'Restart Quiz';
                nextBtn.style.display = 'inline-block';
                nextBtn.onclick = initializeQuiz; // Restart
                return;
            }
            const term = quizShuffledTerms[currentQuizTermIndex];
            document.getElementById('questionTerm').textContent = `${term.english} (${term.polish})`;
            const options = generateSRSMCOptions(term); 
            const optionsList = document.getElementById('optionsList');
            optionsList.innerHTML = '';
            options.forEach(opt => {
                const li = document.createElement('li');
                li.className = 'option-item';
                li.textContent = opt.text;
                li.dataset.correct = opt.isCorrect;
                li.onclick = () => { 
                    optionsList.querySelectorAll('.option-item').forEach(i => i.classList.remove('selected'));
                    li.classList.add('selected');
                };
                optionsList.appendChild(li);
            });
            document.getElementById('currentQuestionDisplay').textContent = currentQuizTermIndex + 1;
            document.getElementById('totalQuestionsDisplay').textContent = quizShuffledTerms.length;
            document.getElementById('quizProgress').style.width = ((currentQuizTermIndex + 1) / quizShuffledTerms.length * 100) + '%';
            submitBtn.style.display = 'inline-block';
            nextBtn.style.display = 'none';
            nextBtn.textContent = 'Next Question';
            nextBtn.onclick = nextQuizQuestion; // Set back to next question
        }
        function submitQuizAnswer() {
            const selectedOption = document.querySelector('#optionsList .option-item.selected');
            if (!selectedOption) { alert("Please select an answer."); return; }

            const isCorrect = selectedOption.dataset.correct === 'true';
            selectedOption.classList.add(isCorrect ? 'correct' : 'incorrect');
            
            if (!isCorrect) { // If incorrect, also show the correct one
                document.querySelectorAll('#optionsList .option-item').forEach(item => {
                    if (item.dataset.correct === 'true') item.classList.add('correct');
                });
            }
            document.querySelectorAll('#optionsList .option-item').forEach(item => item.onclick = null); // Disable further clicks
            document.getElementById('submitQuizBtn').style.display = 'none';
            document.getElementById('nextQuizBtn').style.display = 'inline-block';
        }
        function nextQuizQuestion() {
            currentQuizTermIndex++;
            displayQuizQuestion();
        }

        // --- STUDY GUIDE MODE ---
        function initializeStudyGuide() {
            const studyContent = document.getElementById('studyContent');
            studyContent.innerHTML = '';
            let html = '<div style="display: grid; gap: 15px;">'; 
            vocabularyData.forEach(term => { // Use original vocabularyData for consistent order
                html += `
                    <div style="background: var(--light-gray); padding: 15px; border-radius: var(--border-radius); border-left: 5px solid var(--primary-color);">
                        <h3 style="color: var(--primary-color); margin-bottom: 8px; display:flex; justify-content:space-between; align-items:center;">
                            <span>${term.english} / ${term.polish}</span>
                            <div>
                                <button class="audio-btn" onclick="playAudio('${term.english}', event)">🔊</button>
                            </div>
                        </h3>
                        <p style="margin-bottom: 8px;"><strong>Definition:</strong> ${term.definition}</p>
                        <p style="margin-bottom: 5px; font-style: italic;">EN: ${term.exampleEnglish || 'N/A'}</p>
                        <p style="margin-bottom: 5px; font-style: italic;">PL: ${term.examplePolish || 'N/A'}</p>
                        <small style="color: var(--medium-gray);">Pronunciation Guide: ${term.pronunciation}</small>
                    </div>
                `;
            });
            html += '</div>';
            studyContent.innerHTML = html;
        }

        // --- SRS MODE (Logic remains largely the same, UI rendering functions below) ---
        let srsSessionTerms = [];
        let currentSRSTermIndex = 0;
        let currentSRSType = '';

        function applySRSSettingsAndStart() {
            srsDataGlobal.srsSettings.useWriting = document.getElementById('srsUseWriting').checked;
            srsDataGlobal.srsSettings.useMultipleChoice = document.getElementById('srsUseMC').checked;
            srsDataGlobal.srsSettings.useTrueFalse = document.getElementById('srsUseTF').checked;
            srsDataGlobal.srsSettings.sessionSize = parseInt(document.getElementById('srsSessionSize').value) || 10;
            saveSRSData();
            initializeSRSMode();
        }

        function initializeSRSMode() {
            const srsSessionArea = document.getElementById('srsSessionArea');
            srsSessionArea.innerHTML = ''; 

            const newTermsForPreAssessment = vocabularyData.filter(term => {
                const progress = srsDataGlobal.termsProgress[term.id];
                return !progress || progress.srsStage === 'new';
            }).slice(0, srsDataGlobal.srsSettings.sessionSize);

            if (newTermsForPreAssessment.length > 0) {
                srsSessionTerms = newTermsForPreAssessment;
                currentSRSTermIndex = 0;
                currentSRSType = 'pre-assessment';
                renderSRSCard();
            } else {
                srsSessionTerms = getSRSDueTerms(srsDataGlobal.srsSettings.sessionSize);
                if (srsSessionTerms.length === 0) {
                    srsSessionArea.innerHTML = '<p style="text-align:center; padding:20px; font-weight:bold;">No terms due for review right now. Great job!</p>';
                    updateSRSProgressText("Session complete. Nothing due.");
                    document.getElementById('srsProgressFill').style.width = '100%';
                    return;
                }
                currentSRSTermIndex = 0;
                pickNextSRSType(); 
                renderSRSCard();
            }
            updateSRSProgressText();
        }
        
        function updateSRSProgressText(customText = null) {
            const fill = document.getElementById('srsProgressFill');
            const text = document.getElementById('srsProgressText');
            if (customText) {
                text.textContent = customText;
                return;
            }
            if(srsSessionTerms.length === 0 || currentSRSTermIndex >= srsSessionTerms.length) { // Check if session ended
                 text.textContent = "Session complete.";
                 fill.style.width = '100%';
                 return;
            }
            const progress = srsSessionTerms.length > 0 ? ((currentSRSTermIndex) / srsSessionTerms.length) * 100 : 0;
            fill.style.width = progress + '%';
            text.textContent = `Term ${currentSRSTermIndex +1} of ${srsSessionTerms.length}. Type: ${currentSRSType.replace('-', ' ')}`;
        }

        function pickNextSRSType() {
            const availableTypes = [];
            if (srsDataGlobal.srsSettings.useWriting) availableTypes.push('writing');
            if (srsDataGlobal.srsSettings.useMultipleChoice) availableTypes.push('multiple-choice');
            if (srsDataGlobal.srsSettings.useTrueFalse) availableTypes.push('true-false');

            if (availableTypes.length === 0) { currentSRSType = 'multiple-choice'; return; } 
            currentSRSType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
        }

        function renderSRSCard() {
            const srsSessionArea = document.getElementById('srsSessionArea');
             updateSRSProgressText();


            if (currentSRSTermIndex >= srsSessionTerms.length) {
                srsSessionArea.innerHTML = `<div style="text-align:center; padding:20px;" class="question-card">
                                                <p style="font-size:1.2em; font-weight:bold; margin-bottom:15px;">Session complete!</p>
                                                <button class="btn btn-primary" onclick="applySRSSettingsAndStart()">Start New Session</button>
                                                <button class="btn btn-secondary" onclick="switchMode('study')">Go to Study Guide</button>
                                            </div>`;
                updateOverallStatsDisplay();
                return;
            }

            const term = srsSessionTerms[currentSRSTermIndex];
            let html = '';

            if (currentSRSType === 'pre-assessment') {
                html = `
                    <div class="flashcard-container">
                        <div class="flashcard" id="srsPreAssessmentCard">
                            <div class="flashcard-front">
                                <div class="flashcard-term">${term.english}</div>
                                <small>(${term.polish})</small>
                                <button class="audio-btn" onclick="playAudio('${term.english}', event)" style="margin-top:10px;">🔊</button>
                                <button class="btn btn-sm btn-info" style="margin-top:15px;" onclick="event.stopPropagation(); document.getElementById('srsPreAssessmentCard').classList.toggle('flipped')">Show Definition</button>
                            </div>
                            <div class="flashcard-back">
                                <div class="flashcard-definition" style="font-size:1.1rem;">${term.definition}</div>
                                <button class="btn btn-sm btn-info" style="margin-top:15px;" onclick="event.stopPropagation(); document.getElementById('srsPreAssessmentCard').classList.toggle('flipped')">Show Term</button>
                            </div>
                        </div>
                    </div>
                    <div class="srs-pre-assessment-controls controls">
                        <button class="btn btn-danger" onclick="handleSRSOutcome('dont_know')">Don't Know</button>
                        <button class="btn btn-warning" onclick="handleSRSOutcome('practicing')">Practicing</button>
                        <button class="btn btn-success" onclick="handleSRSOutcome('know')">Know It!</button>
                    </div>`;
            } else if (currentSRSType === 'writing') {
                const promptEnglish = Math.random() > 0.5; 
                const questionText = promptEnglish ? term.english : term.polish;
                const expectedAnswer = promptEnglish ? term.polish : term.english;
                html = `
                    <div class="question-card">
                        <p>What is the ${promptEnglish ? 'Polish translation' : 'English term'} for: <strong>${questionText}</strong>?
                           <button class="audio-btn" onclick="playAudio('${questionText}', event)">🔊</button>
                        </p>
                        <input type="text" id="srsWritingInput" class="form-control" placeholder="Type your answer">
                        <div id="srsFeedback" style="margin-top:10px; min-height:1.5em;"></div>
                        <button class="btn btn-primary" onclick="checkSRSWritingAnswer('${expectedAnswer.toLowerCase().trim()}')">Submit</button>
                    </div>`;
            } else if (currentSRSType === 'multiple-choice') {
                const options = generateSRSMCOptions(term); 
                html = `
                    <div class="question-card">
                        <p>Choose the correct definition for: <strong>${term.english} (${term.polish})</strong>?
                            <button class="audio-btn" onclick="playAudio('${term.english}', event)">🔊</button>
                        </p>
                        <ul class="options-list" id="srsMcOptions">
                            ${options.map(opt => `<li class="option-item" data-correct="${opt.isCorrect}">${opt.text}</li>`).join('')}
                        </ul>
                        <div id="srsFeedback" style="margin-top:10px; min-height:1.5em;"></div>
                        <button class="btn btn-primary" id="srsMcSubmitBtn" onclick="checkSRSMCOption()">Submit</button>
                    </div>`;
            } else if (currentSRSType === 'true-false') {
                const isTrueStatement = Math.random() > 0.5;
                let statement = '';
                let actualCorrectAnswerForTF = isTrueStatement; 

                if (isTrueStatement) { 
                    statement = `"${term.english}" means "${term.definition}".`;
                } else { 
                    let falseDefinitionTerm = vocabularyData.find(t => t.id !== term.id && t.definition !== term.definition);
                    if (!falseDefinitionTerm || falseDefinitionTerm.definition === term.definition) { 
                        statement = `"${term.english}" means "This is an intentionally incorrect definition for testing."`;
                    } else {
                        statement = `"${term.english}" means "${falseDefinitionTerm.definition}".`;
                    }
                }
                html = `
                    <div class="question-card">
                        <p>Is the following statement true or false?</p>
                        <p><em>${statement}</em>
                           <button class="audio-btn" onclick="playAudio('${term.english}', event)">🔊</button>
                        </p>
                        <div id="srsFeedback" style="margin-top:10px; min-height:1.5em;"></div>
                        <div class="controls">
                            <button class="btn btn-success" onclick="checkSRSTrueFalseAnswer(true, ${actualCorrectAnswerForTF})">True</button>
                            <button class="btn btn-danger" onclick="checkSRSTrueFalseAnswer(false, ${actualCorrectAnswerForTF})">False</button>
                        </div>
                    </div>`;
            }
            srsSessionArea.innerHTML = html;
            if(currentSRSType === 'multiple-choice') { 
                document.querySelectorAll('#srsMcOptions .option-item').forEach(item => {
                    item.addEventListener('click', function() {
                        document.querySelectorAll('#srsMcOptions .option-item').forEach(i => i.classList.remove('selected'));
                        this.classList.add('selected');
                    });
                });
            }
        }
        
        function generateSRSMCOptions(correctTerm) { // Helper for MCQs
            const options = [{ text: correctTerm.definition, isCorrect: true }];
            let otherTerms = vocabularyData.filter(t => t.id !== correctTerm.id);
            shuffleArray(otherTerms);
            for (let i = 0; i < 3 && i < otherTerms.length; i++) {
                options.push({ text: otherTerms[i].definition, isCorrect: false });
            }
            shuffleArray(options);
            return options;
        }

        function handleSRSOutcome(outcome) {
            const term = srsSessionTerms[currentSRSTermIndex];
            updateSRSTerm(term.id, outcome, currentSRSType);
            
            currentSRSTermIndex++;
            if (currentSRSType === 'pre-assessment' && currentSRSTermIndex >= srsSessionTerms.length) {
                initializeSRSMode(); 
            } else {
                 if (currentSRSType !== 'pre-assessment') pickNextSRSType(); 
                renderSRSCard();
            }
        }

        function checkSRSWritingAnswer(correctAnswer) {
            const userAnswer = document.getElementById('srsWritingInput').value.trim().toLowerCase();
            const feedbackDiv = document.getElementById('srsFeedback');
            const outcome = (userAnswer === correctAnswer) ? 'correct' : 'incorrect';
            feedbackDiv.innerHTML = `<p style="color:${outcome === 'correct' ? 'var(--success-color)' : 'var(--error-color)'};">${outcome === 'correct' ? 'Correct!' : 'Incorrect. Correct answer: ' + correctAnswer}</p>`;
            disableInputAndProceed(outcome);
        }

        function checkSRSMCOption() {
            const selectedOption = document.querySelector('#srsMcOptions .option-item.selected');
            if (!selectedOption) { alert("Please select an answer."); return; }
            const feedbackDiv = document.getElementById('srsFeedback');
            const isCorrect = selectedOption.dataset.correct === 'true';
            const outcome = isCorrect ? 'correct' : 'incorrect';

            document.querySelectorAll('#srsMcOptions .option-item').forEach(item => item.onclick = null); 
            const submitBtn = document.getElementById('srsMcSubmitBtn');
            if(submitBtn) submitBtn.disabled = true;


            if (isCorrect) {
                selectedOption.classList.add('correct');
                feedbackDiv.innerHTML = '<p style="color:var(--success-color);">Correct!</p>';
            } else {
                selectedOption.classList.add('incorrect');
                const correctEl = document.querySelector('#srsMcOptions .option-item[data-correct="true"]');
                if(correctEl) correctEl.classList.add('correct');
                feedbackDiv.innerHTML = `<p style="color:var(--error-color);">Incorrect. Correct answer highlighted.</p>`;
            }
            disableInputAndProceed(outcome);
        }

        function checkSRSTrueFalseAnswer(userAnswer, actualCorrectAnswerForTF) {
            const feedbackDiv = document.getElementById('srsFeedback');
            const term = srsSessionTerms[currentSRSTermIndex]; 
            const outcome = (userAnswer === actualCorrectAnswerForTF) ? 'correct' : 'incorrect';
            
            if (outcome === 'correct') {
                 feedbackDiv.innerHTML = '<p style="color:var(--success-color);">Correct!</p>';
            } else {
                 feedbackDiv.innerHTML = `<p style="color:var(--error-color);">Incorrect. The statement was ${actualCorrectAnswerForTF ? 'True' : 'False'}.</p> 
                                          <small>(${term.english} means: ${term.definition})</small>`;
            }
            disableInputAndProceed(outcome);
        }

        function disableInputAndProceed(outcome) {
            const srsSessionArea = document.getElementById('srsSessionArea');
            srsSessionArea.querySelectorAll('button, input:not([type=checkbox])').forEach(el => {
                if(!el.closest('.srs-settings-panel')) el.disabled = true; // Don't disable settings panel buttons
            });


            setTimeout(() => {
                handleSRSOutcome(outcome); 
            }, 2000); 
        }

    </script>
</body>
</html>
