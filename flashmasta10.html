<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlashMasta V10 - Language Learning App</title>
    <!-- Google API Scripts (for Drive integration) -->
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <!-- CSS Styles -->
    <style>
        /* 
        ==========================================
        CSS VARIABLES AND BASE STYLES 
        ==========================================
        */
        :root {
            /* Primary Theme Colors */
            --primary-color: #4a90e2;
            --primary-dark: #3a7cd0;
            --primary-light: #6ba5e9;
            --secondary-color: #f5f5f5;
            
            /* Semantic Colors */
            --success-color: #2ecc71;
            --warning-color: #f1c40f;
            --error-color: #e74c3c;
            --info-color: #3498db;
            
            /* Background/Text Colors */
            --bg-color: #f0f2f5;
            --card-bg: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #666666;
            --text-muted: #999999;
            
            /* Spacing */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
            
            /* Borders & Shadows */
            --border-radius: 8px;
            --border-radius-sm: 4px;
            --border-radius-lg: 12px;
            --border-color: #e1e5eb;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 15px rgba(0,0,0,0.1);
            
            /* Typography */
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --font-size-xs: 12px;
            --font-size-sm: 14px;
            --font-size-md: 16px;
            --font-size-lg: 20px;
            --font-size-xl: 24px;
        }

        /* Base Styles */
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-primary);
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }

        /* 
        ==========================================
        LAYOUT COMPONENTS 
        ==========================================
        */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--space-md);
        }

        /* App Header */
        .app-header {
            background-color: var(--primary-color);
            color: white;
            padding: var(--space-md);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            box-shadow: var(--shadow-sm);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .app-title {
            font-size: var(--font-size-lg);
            margin: 0;
            font-weight: bold;
        }

        .app-logo {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .nav-tabs {
            display: flex;
            background-color: var(--primary-dark);
            overflow-x: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }

        .nav-tabs::-webkit-scrollbar {
            display: none; /* Chrome/Safari/Opera */
        }

        .nav-tab {
            padding: var(--space-md) var(--space-lg);
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
            white-space: nowrap;
        }

        .nav-tab.active {
            background-color: var(--primary-color);
            border-bottom: 3px solid white;
        }

        .nav-tab:hover:not(.active) {
            background-color: var(--primary-light);
        }

        /* Main Content Area */
        .main-content {
            margin-top: 120px; /* Header height + padding */
            padding-bottom: var(--space-xl);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease-in;
        }

        .tab-content.active {
            display: block;
        }

        /* 
        ==========================================
        UI COMPONENTS 
        ==========================================
        */
        .card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
            padding: var(--space-lg);
            margin-bottom: var(--space-lg);
            border: 1px solid var(--border-color);
        }

        .card-title {
            font-size: var(--font-size-lg);
            font-weight: bold;
            margin-top: 0;
            margin-bottom: var(--space-md);
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 8px;
        }

        /* Buttons */
        button, .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            margin: 5px;
        }

        button:hover, .btn:hover {
            background-color: var(--primary-dark);
        }

        button.secondary, .btn.secondary {
            background-color: var(--secondary-color);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        button.secondary:hover, .btn.secondary:hover {
            background-color: #e8e8e8;
        }

        button.success, .btn.success {
            background-color: var(--success-color);
        }

        button.error, .btn.error {
            background-color: var(--error-color);
        }

        button.small, .btn.small {
            padding: 5px 10px;
            font-size: var(--font-size-sm);
        }

        button:disabled, .btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* Forms */
        .form-group {
            margin-bottom: var(--space-md);
        }

        label {
            display: block;
            margin-bottom: var(--space-xs);
            font-weight: bold;
            color: var(--text-primary);
        }

        input[type="text"], 
        input[type="password"],
        input[type="email"],
        input[type="number"],
        input[type="file"],
        textarea,
        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: var(--border-radius);
            font-size: 16px;
            transition: border-color 0.3s;
            box-sizing: border-box;
        }

        input[type="text"]:focus, 
        input[type="password"]:focus,
        input[type="email"]:focus,
        input[type="number"]:focus,
        input[type="file"]:focus,
        textarea:focus,
        select:focus {
            border-color: var(--primary-color);
            outline: none;
        }

        /* Exercise Cards */
        .exercise-cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: var(--space-md);
            margin-top: var(--space-md);
        }

        .exercise-card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
            padding: var(--space-lg);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 1px solid var(--border-color);
        }

        .exercise-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-md);
        }

        .exercise-card-header {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            margin-bottom: var(--space-md);
        }

        .exercise-card-icon {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: var(--primary-light);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
        }

        .exercise-card-title {
            font-size: var(--font-size-md);
            font-weight: bold;
            margin: 0;
        }

        .exercise-card-description {
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
            margin-bottom: 0;
        }

        /* Stats Container */
        .stats-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            padding: 15px;
            background-color: var(--secondary-color);
            border-radius: var(--border-radius);
            margin: 15px 0;
        }

        .stat-item {
            text-align: center;
            margin: var(--space-xs) var(--space-md);
            min-width: 100px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .stat-label {
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-color);
            transition: width 0.3s ease;
        }

        /* Flashcard Component */
        .flashcard {
            perspective: 1000px;
            width: 300px;
            margin: 0 auto;
            border: 4px solid transparent;
            transition: border-color 0.3s;
        }

        .flashcard[data-difficulty="learnt"] { 
            border-color: var(--success-color); 
        }
        
        .flashcard[data-difficulty="easy"] { 
            border-color: var(--info-color); 
        }
        
        .flashcard[data-difficulty="medium"] { 
            border-color: var(--warning-color); 
        }
        
        .flashcard[data-difficulty="hard"] { 
            border-color: var(--error-color); 
        }
        
        .flashcard[data-difficulty="mastered"] { 
            border-color: #9b59b6; 
            border-style: double; 
            border-width: 6px; 
        }

        .flashcard-inner {
            position: relative;
            width: 100%;
            height: 200px;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            cursor: pointer;
        }

        .flashcard.flipped .flashcard-inner {
            transform: rotateY(180deg);
        }

        .flashcard-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--primary-color);
            border-radius: var(--border-radius);
            background-color: var(--secondary-color);
            font-size: 20px;
            padding: 10px;
            box-sizing: border-box;
        }

        .flashcard-back {
            transform: rotateY(180deg);
        }

        /* Difficulty Tags */
        .difficulty-tag {
            display: inline-block;
            padding: 5px 15px;
            margin: 5px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .difficulty-tag.learnt { 
            background-color: var(--success-color); 
            color: white; 
        }
        
        .difficulty-tag.easy { 
            background-color: var(--info-color); 
            color: white; 
        }
        
        .difficulty-tag.medium { 
            background-color: var(--warning-color); 
            color: white; 
        }
        
        .difficulty-tag.hard { 
            background-color: var(--error-color); 
            color: white; 
        }
        
        .difficulty-tag.mastered { 
            background-color: #9b59b6; 
            color: white; 
        }

        .difficulty-tag:hover {
            transform: scale(1.05);
            opacity: 0.9;
        }

        .difficulty-tag.selected {
            transform: scale(1.1);
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        /* Word List */
        .vocabulary-list {
            margin-top: var(--space-md);
        }

        .vocabulary-controls {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
        }

        .vocabulary-filters {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
            align-items: center;
        }

        .search-box {
            flex: 1;
            min-width: 200px;
            display: flex;
        }

        .search-box input {
            border-radius: var(--border-radius) 0 0 var(--border-radius);
            border-right: none;
        }

        .search-box button {
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
            margin: 0;
        }

        .filter-dropdown {
            min-width: 150px;
        }

        .word-item {
            border-bottom: 1px solid var(--border-color);
            padding: var(--space-md) 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: var(--space-sm);
        }

        .word-details {
            flex-grow: 1;
            min-width: 200px;
        }

        .word-text {
            font-weight: bold;
            margin-right: var(--space-sm);
        }

        .word-translation {
            color: var(--text-secondary);
        }

        .word-actions {
            display: flex;
            gap: var(--space-xs);
            flex-wrap: wrap;
        }

        .tag {
            background-color: var(--primary-color);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 4px;
            display: inline-block;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1500;
            overflow-y: auto;
        }

        .modal-content {
            background: white;
            max-width: 800px;
            width: 90%;
            margin: 40px auto;
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-md);
            padding-bottom: var(--space-sm);
            border-bottom: 1px solid var(--border-color);
        }

        .modal-title {
            font-size: var(--font-size-lg);
            margin: 0;
            color: var(--primary-color);
        }

        .modal-close {
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
            border: none;
            background: transparent;
            padding: 0;
            margin: 0;
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal-body {
            margin-bottom: var(--space-md);
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: var(--space-sm);
            padding-top: var(--space-sm);
            border-top: 1px solid var(--border-color);
        }

        .large-modal .modal-content {
            max-width: 1000px;
        }

        /* Image Browser */
        .image-browser-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-md);
            flex-wrap: wrap;
            gap: var(--space-sm);
        }

        .image-search {
            flex: 1;
            min-width: 200px;
            display: flex;
        }

        .image-categories {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-xs);
        }

        .category-btn {
            padding: 5px 10px;
            background-color: var(--secondary-color);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-sm);
            cursor: pointer;
            transition: all 0.2s;
        }

        .category-btn:hover {
            background-color: var(--primary-light);
            color: white;
        }

        .category-btn.active {
            background-color: var(--primary-color);
            color: white;
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .image-item {
            position: relative;
            border-radius: var(--border-radius-sm);
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
            aspect-ratio: 1;
        }

        .image-item:hover {
            transform: scale(1.05);
        }

        .image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border: 2px solid transparent;
        }

        .image-item.selected img {
            border-color: var(--primary-color);
        }

        .image-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: var(--space-md);
            margin-top: var(--space-md);
        }

        /* Onboarding */
        .onboarding-step {
            display: none;
            text-align: center;
            padding: var(--space-lg);
        }

        .onboarding-step.active {
            display: block;
        }

        .onboarding-image {
            max-width: 100%;
            height: auto;
            margin-bottom: var(--space-lg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-md);
        }

        .onboarding-progress {
            display: flex;
            justify-content: center;
            margin-top: var(--space-lg);
            gap: var(--space-md);
        }

        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--border-color);
            cursor: pointer;
            transition: all 0.3s;
        }

        .progress-dot.active {
            background-color: var(--primary-color);
            transform: scale(1.2);
        }

        .progress-dot:hover:not(.active) {
            background-color: var(--primary-light);
        }

        /* Achievement System */
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: var(--space-md);
            max-height: 70vh;
            overflow-y: auto;
            padding: var(--space-sm);
        }

        .achievement-card {
            background: var(--secondary-color);
            padding: var(--space-md);
            border-radius: var(--border-radius);
            text-align: center;
            position: relative;
            transition: transform 0.2s;
        }

        .achievement-card.achieved {
            background: linear-gradient(45deg, rgba(241, 196, 15, 0.1), rgba(243, 156, 18, 0.1));
            border: 2px solid #f1c40f;
        }

        .achievement-card:hover {
            transform: translateY(-2px);
        }

        .achievement-icon {
            font-size: 32px;
            margin-bottom: var(--space-sm);
        }

        .achievement-title {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .achievement-description {
            font-size: var(--font-size-sm);
            color: var(--text-secondary);
            margin-bottom: var(--space-sm);
        }

        .achievement-progress {
            height: 4px;
            background: #ddd;
            border-radius: 2px;
            overflow: hidden;
            margin-top: var(--space-sm);
        }

        .achievement-progress-bar {
            height: 100%;
            background: var(--primary-color);
            transition: width 0.3s;
        }

        .achievement-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            gap: 15px;
            transform: translateX(120%);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 2000;
        }

        .achievement-notification.show {
            transform: translateX(0);
        }

        /* Avatar System */
        .avatar-header {
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
        }

        .avatar-display {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .avatar-display:hover {
            transform: scale(1.1);
        }

        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
            padding: 20px;
        }

        .avatar-option {
            text-align: center;
            padding: 10px;
            border: 2px solid transparent;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s;
        }

        .avatar-option:hover {
            transform: scale(1.05);
            background-color: var(--secondary-color);
        }

        .avatar-option.selected {
            border-color: var(--primary-color);
            background-color: var(--secondary-color);
        }

        .avatar-option img {
            width: 80px;
            height: 80px;
            margin-bottom: 5px;
            border-radius: 50%;
        }

        .avatar-name {
            font-size: 12px;
            color: var(--text-primary);
        }

        /* User Stats Display */
        .user-stats {
            display: flex;
            flex-direction: column;
            font-size: var(--font-size-sm);
        }

        .word-count {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 4px;
        }

        .count-item {
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
        }

        .count-mastered { background-color: #9b59b6; }
        .count-learnt { background-color: var(--success-color); }
        .count-easy { background-color: var(--info-color); }
        .count-medium { background-color: var(--warning-color); }
        .count-hard { background-color: var(--error-color); }

        /* Google Drive UI */
        .google-drive-status {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
            padding: var(--space-sm);
            border-radius: var(--border-radius);
            background-color: var(--secondary-color);
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--error-color);
        }

        .status-indicator.connected {
            background-color: var(--success-color);
        }

        .google-drive-info {
            margin-top: var(--space-md);
            padding: var(--space-md);
            border-radius: var(--border-radius);
            background-color: var(--secondary-color);
            font-size: var(--font-size-sm);
        }

        .google-drive-files {
            margin-top: var(--space-md);
            max-height: 200px;
            overflow-y: auto;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-sm);
            border-bottom: 1px solid var(--border-color);
        }

        .file-info {
            flex-grow: 1;
        }

        .file-name {
            font-weight: bold;
        }

        .file-date {
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
        }

        .file-actions {
            display: flex;
            gap: var(--space-xs);
        }

        /* Result Messages */
        .result-message {
            padding: 10px;
            margin: 10px 0;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: bold;
        }

        .result-message.success {
            background-color: var(--success-color);
            color: white;
        }

        .result-message.error {
            background-color: var(--error-color);
            color: white;
        }

        /* Tooltips */
        .tooltip-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2000;
        }

        .tooltip {
            position: absolute;
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            padding: var(--space-md);
            max-width: 300px;
            pointer-events: auto;
            z-index: 2001;
            animation: tooltip-fade-in 0.3s ease-out;
        }

        .tooltip-arrow {
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            transform: rotate(45deg);
            z-index: -1;
            box-shadow: var(--shadow-sm);
        }

        .tooltip[data-position="top"] .tooltip-arrow {
            bottom: -8px;
            left: calc(50% - 8px);
        }

        .tooltip[data-position="bottom"] .tooltip-arrow {
            top: -8px;
            left: calc(50% - 8px);
        }

        .tooltip[data-position="left"] .tooltip-arrow {
            right: -8px;
            top: calc(50% - 8px);
        }

        .tooltip[data-position="right"] .tooltip-arrow {
            left: -8px;
            top: calc(50% - 8px);
        }

        .tooltip-title {
            font-weight: bold;
            margin-top: 0;
            color: var(--primary-color);
        }

        .tooltip-content p {
            margin-bottom: var(--space-md);
        }

        /* 
        ==========================================
        ANIMATIONS 
        ==========================================
        */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes tooltip-fade-in {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        @keyframes celebrate {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .celebrating {
            animation: celebrate 0.5s ease-out;
        }

        /* 
        ==========================================
        RESPONSIVE DESIGN 
        ==========================================
        */
        @media (max-width: 768px) {
            .stats-container {
                flex-direction: column;
                align-items: center;
            }

            .card {
                padding: var(--space-md);
            }

            .modal-content {
                width: 95%;
                margin: 20px auto;
                padding: 15px;
            }

            .exercise-cards {
                grid-template-columns: 1fr;
            }

            .avatar-grid {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            }

            .word-actions {
                margin-top: var(--space-xs);
            }
        }

        @media (max-width: 576px) {
            :root {
                --space-lg: 16px;
                --space-md: 12px;
                --space-sm: 6px;
            }

            .app-header {
                flex-direction: column;
                align-items: stretch;
                padding: var(--space-sm);
            }

            .app-logo {
                justify-content: center;
                margin-bottom: var(--space-xs);
            }

            .nav-tabs {
                justify-content: space-between;
            }

            .nav-tab {
                padding: var(--space-sm) var(--space-md);
                font-size: var(--font-size-sm);
            }

            .flashcard {
                width: 250px;
            }

            .main-content {
                margin-top: 150px;
            }

            .vocabulary-controls, 
            .vocabulary-filters {
                flex-direction: column;
                gap: var(--space-xs);
            }

            .search-box {
                width: 100%;
            }

            .word-item {
                flex-direction: column;
                align-items: flex-start;
            }

            .word-actions {
                align-self: flex-end;
            }
        }
    </style>
</head>
<body>
    <!-- App Header -->
    <header class="app-header">
        <div class="app-logo">
            <h1 class="app-title">FlashMasta V10</h1>
            <div id="avatarContainer" class="avatar-header">
                <img id="currentAvatar" class="avatar-display" src="https://api.dicebear.com/9.x/micah/svg?seed=default" alt="Your avatar">
            </div>
        </div>
        <nav class="nav-tabs">
            <div class="nav-tab active" data-tab="learn">Learn</div>
            <div class="nav-tab" data-tab="practice">Practice</div>
            <div class="nav-tab" data-tab="vocabulary">Vocabulary</div>
            <div class="nav-tab" data-tab="progress">Progress</div>
            <div class="nav-tab" data-tab="settings">Settings</div>
        </nav>
    </header>

    <!-- Main Content Area -->
    <main class="main-content container">
        <!-- Learn Tab -->
        <div id="learn-tab" class="tab-content active">
            <div class="card">
                <h2 class="card-title">Your Learning Dashboard</h2>
                <div class="stats-container">
                    <div class="stat-item">
                        <div class="stat-value" id="totalScore">0</div>
                        <div class="stat-label">Total Score</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="correctAnswers">0</div>
                        <div class="stat-label">Correct Answers</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalAttempts">0</div>
                        <div class="stat-label">Total Attempts</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="masteredWords">0</div>
                        <div class="stat-label">Mastered Words</div>
                    </div>
                </div>
                <div class="difficulty-progress">
                    <h3>Vocabulary Progress</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" id="vocabularyProgressFill" style="width: 0%"></div>
                    </div>
                    <div class="word-count">
                        <span class="count-item count-hard" id="countHard">0</span>
                        <span class="count-item count-medium" id="countMedium">0</span>
                        <span class="count-item count-easy" id="countEasy">0</span>
                        <span class="count-item count-learnt" id="countLearnt">0</span>
                        <span class="count-item count-mastered" id="countMastered">0</span>
                    </div>
                </div>
            </div>

            <h2>Recommended Exercises</h2>
            <div class="exercise-cards">
                <div class="exercise-card" onclick="generateSRS()">
                    <div class="exercise-card-header">
                        <div class="exercise-card-icon">📚</div>
                        <div>
                            <h3 class="exercise-card-title">SRS Practice</h3>
                        </div>
                    </div>
                    <p class="exercise-card-description">
                        Smart review of words that need practice based on your performance
                    </p>
                </div>
                <div class="exercise-card" onclick="generateFlashcard()">
                    <div class="exercise-card-header">
                        <div class="exercise-card-icon">🔄</div>
                        <div>
                            <h3 class="exercise-card-title">Flashcards</h3>
                        </div>
                    </div>
                    <p class="exercise-card-description">
                        Review words with flashcards and mark their difficulty
                    </p>
                </div>
                <div class="exercise-card" onclick="generateWriting()">
                    <div class="exercise-card-header">
                        <div class="exercise-card-icon">✏️</div>
                        <div>
                            <h3 class="exercise-card-title">Writing Exercise</h3>
                        </div>
                    </div>
                    <p class="exercise-card-description">
                        Practice typing translations to reinforce your memory
                    </p>
                </div>
            </div>
        </div>

        <!-- Practice Tab -->
        <div id="practice-tab" class="tab-content">
            <h2>Choose an Exercise</h2>
            <div class="exercise-cards">
                <div class="exercise-card" onclick="generateFlashcard()">
                    <div class="exercise-card-header">
                        <div class="exercise-card-icon">🔄</div>
                        <div>
                            <h3 class="exercise-card-title">Flashcards</h3>
                        </div>
                    </div>
                    <p class="exercise-card-description">
                        Review words with flashcards and mark their difficulty
                    </p>
                </div>
                <div class="exercise-card" onclick="generateSRS()">
                    <div class="exercise-card-header">
                        <div class="exercise-card-icon">📚</div>
                        <div>
                            <h3 class="exercise-card-title">SRS Practice</h3>
                        </div>
                    </div>
                    <p class="exercise-card-description">
                        Smart review based on your learning progress
                    </p>
                </div>
                <div class="exercise-card" onclick="generateTrueFalse()">
                    <div class="exercise-card-header">
                        <div class="exercise-card-icon">✓✗</div>
                        <div>
                            <h3 class="exercise-card-title">True/False</h3>
                        </div>
                    </div>
                    <p class="exercise-card-description">
                        Identify if word pairs are correctly matched
                    </p>
                </div>
                <div class="exercise-card" onclick="generateMultipleChoice()">
                    <div class="exercise-card-header">
                        <div class="exercise-card-icon">📝</div>
                        <div>
                            <h3 class="exercise-card-title">Multiple Choice</h3>
                        </div>
                    </div>
                    <p class="exercise-card-description">
                        Select the correct translation from options
                    </p>
                </div>
                <div class="exercise-card" onclick="generateMatching()">
                    <div class="exercise-card-header">
                        <div class="exercise-card-icon">🔗</div>
                        <div>
                            <h3 class="exercise-card-title">Matching</h3>
                        </div>
                    </div>
                    <p class="exercise-card-description">
                        Match words with their translations
                    </p>
                </div>
                <div class="exercise-card" onclick="generateWriting()">
                    <div class="exercise-card-header">
                        <div class="exercise-card-icon">✏️</div>
                        <div>
                            <h3 class="exercise-card-title">Writing</h3>
                        </div>
                    </div>
                    <p class="exercise-card-description">
                        Type in translations to practice recall
                    </p>
                </div>
            </div>
        </div>

        <!-- Vocabulary Tab -->
        <div id="vocabulary-tab" class="tab-content">
            <h2>Manage Your Vocabulary</h2>
            <div class="card">
                <div class="vocabulary-controls">
                    <button class="btn" id="addWordBtn" onclick="showAddWordModal()">Add New Word</button>
                    <button class="btn secondary" onclick="saveToFile()">Export Vocabulary</button>
                    <button class="btn secondary" onclick="document.getElementById('fileInput').click()">Import Vocabulary</button>
                    <input type="file" id="fileInput" style="display: none" onchange="loadFromFile(this)">
                </div>
                <div class="vocabulary-filters">
                    <div class="search-box">
                        <input type="text" id="vocabSearch" placeholder="Search vocabulary...">
                        <button onclick="searchVocabulary()">Search</button>
                    </div>
                    <select class="filter-dropdown" id="difficultyFilter" onchange="filterVocabulary()">
                        <option value="all">All Difficulties</option>
                        <option value="hard">Hard</option>
                        <option value="medium">Medium</option>
                        <option value="easy">Easy</option>
                        <option value="learnt">Learnt</option>
                        <option value="mastered">Mastered</option>
                    </select>
                    <select class="filter-dropdown" id="tagFilter" onchange="filterVocabulary()">
                        <option value="all">All Tags</option>
                    </select>
                </div>
                <div class="vocabulary-list" id="vocabList">
                    <!-- Vocabulary items will be added here dynamically -->
                </div>
            </div>
        </div>

        <!-- Progress Tab -->
        <div id="progress-tab" class="tab-content">
            <h2>Your Progress</h2>
            <div class="card">
                <h2 class="card-title">Learning Statistics</h2>
                <div class="stats-container">
                    <div class="stat-item">
                        <div class="stat-value" id="progressTotalScore">0</div>
                        <div class="stat-label">Total Score</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="progressCorrectAnswers">0</div>
                        <div class="stat-label">Correct Answers</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="progressAccuracy">0%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="progressMasteredWords">0</div>
                        <div class="stat-label">Mastered Words</div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2 class="card-title">Vocabulary Mastery</h2>
                <div class="difficulty-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="masteryProgressFill" style="width: 0%"></div>
                    </div>
                    <div class="word-count">
                        <span class="count-item count-hard" id="masteryCountHard">0</span>
                        <span class="count-item count-medium" id="masteryCountMedium">0</span>
                        <span class="count-item count-easy" id="masteryCountEasy">0</span>
                        <span class="count-item count-learnt" id="masteryCountLearnt">0</span>
                        <span class="count-item count-mastered" id="masteryCountMastered">0</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2 class="card-title">Achievements</h2>
                <button class="btn" onclick="showAchievements()">View All Achievements</button>
                <div class="achievements-preview">
                    <!-- Preview of recent or highlighted achievements -->
                </div>
            </div>
        </div>

        <!-- Settings Tab -->
        <div id="settings-tab" class="tab-content">
            <h2>Settings</h2>
            <div class="card">
                <h2 class="card-title">Google Drive Integration</h2>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="useGoogleDrive"> Use Google Drive for storage
                    </label>
                    <p class="help-text">Store your vocabulary in Google Drive to access from any device</p>
                </div>
                <div id="googleDriveSettings" style="display: none;">
                    <div class="google-drive-status">
                        <div class="status-indicator" id="driveStatusIndicator"></div>
                        <span id="driveStatusText">Not connected</span>
                    </div>
                    <div class="form-group">
                        <label>Client ID:</label>
                        <input type="text" id="googleClientId" placeholder="YOUR_CLIENT_ID.apps.googleusercontent.com">
                    </div>
                    <div class="form-group">
                        <label>API Key:</label>
                        <input type="text" id="googleApiKey" placeholder="YOUR_API_KEY">
                    </div>
                    <button class="btn" id="connectGoogleDriveBtn">Connect to Google Drive</button>
                    <button class="btn secondary" id="disconnectGoogleDriveBtn" style="display: none;">Disconnect</button>
                    <div class="google-drive-info">
                        <h4>How to get Google Drive API credentials:</h4>
                        <ol>
                            <li>Go to the <a href="https://console.cloud.google.com/" target="_blank">Google Cloud Console</a></li>
                            <li>Create a new project</li>
                            <li>Enable the Google Drive API</li>
                            <li>Create OAuth credentials for a web application</li>
                            <li>Add your website URL to the authorized JavaScript origins</li>
                            <li>Copy the Client ID and API Key to the fields above</li>
                        </ol>
                    </div>
                </div>
                <div id="googleDriveFiles" class="google-drive-files" style="display: none;">
                    <h3>Your Files on Google Drive</h3>
                    <div id="driveFilesList">
                        <!-- Google Drive files will be listed here -->
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2 class="card-title">Avatar Settings</h2>
                <button class="btn" onclick="showAvatarSelector()">Change Avatar</button>
            </div>
            
            <div class="card">
                <h2 class="card-title">Theme Settings</h2>
                <div class="form-group">
                    <label>Primary Color:</label>
                    <input type="color" id="themeColor" value="#4a90e2" onchange="updateThemeColor(this.value)">
                </div>
                <div class="form-group">
                    <label>Font Size:</label>
                    <select id="fontSize" onchange="updateFontSize(this.value)">
                        <option value="small">Small</option>
                        <option value="medium" selected>Medium</option>
                        <option value="large">Large</option>
                    </select>
                </div>
            </div>
        </div>
    </main>

    <!-- Exercise Panels -->
    <!-- True/False Exercise -->
    <div id="trueFalseExercise" class="exercise card" style="display:none">
        <h2 class="card-title">True/False Exercise</h2>
        <div class="score-display">Current Score: <span id="tfScore">0</span></div>
        <div id="tfQuestion">
            <img id="tfImage" style="max-width: 300px; display: block; margin: 0 auto;">
            <p>Polish word: <span id="tfPolish"></span></p>
            <p>English translation: <span id="tfEnglish"></span></p>
            <button onclick="checkTrueFalse(true)">True</button>
            <button onclick="checkTrueFalse(false)">False</button>
        </div>
        <div id="tfResult" class="result-message"></div>
        <button class="btn secondary" onclick="hideExercise('trueFalseExercise')">Close Exercise</button>
    </div>

    <!-- Multiple Choice Quiz Exercise -->
    <div id="multipleChoiceExercise" class="exercise card" style="display:none">
        <h2 class="card-title">Multiple Choice Quiz</h2>
        <div class="score-display">Current Score: <span id="mcScore">0</span></div>
        <div id="mcQuestion">
            <p>Polish word: <span id="mcPolish"></span></p>
            <div id="mcOptions"></div>
        </div>
        <div id="mcResult" class="result-message"></div>
        <button class="btn secondary" onclick="hideExercise('multipleChoiceExercise')">Close Exercise</button>
    </div>

    <!-- SRS Exercise -->
    <div id="srsExercise" class="exercise card" style="display:none">
        <h2 class="card-title">SRS Exercise</h2>
        <div class="score-display">Current Score: <span id="srsScore">0</span></div>
        <div id="srsQuestion">
            <div class="progress-info">
                <div id="srsProgress"></div>
                <div class="progress-bar">
                    <div id="srsProgressFill" class="progress-fill"></div>
                </div>
                <div class="difficulty-progress">
                    <span>Hard</span>
                    <span>Medium</span>
                    <span>Easy</span>
                    <span>Learnt</span>
                    <span>Mastered</span>
                </div>
                <div id="srsNextMilestone" class="next-milestone"></div>
            </div>
            <p>Polish word: <span id="srsPolish"></span></p>
            <div id="srsMultipleChoice" style="display:none">
                <div id="srsOptions"></div>
            </div>
            <div id="srsWriting" style="display:none">
                <div class="form-group">
                    <input type="text" id="srsAnswer" placeholder="Type English translation...">
                </div>
                <button onclick="checkSRS()">Check Answer</button>
            </div>
        </div>
        <div id="srsResult" class="result-message"></div>
        <button class="btn secondary" onclick="hideExercise('srsExercise')">Close Exercise</button>
    </div>

    <!-- Flashcard Mode -->
    <div id="flashcardExercise" class="exercise card" style="display:none">
        <h2 class="card-title">Flashcard Mode</h2>
        <div class="flashcard" onclick="flipFlashcard()">
            <div class="flashcard-inner" id="flashcardInner">
                <div class="flashcard-face" id="flashcardFront"></div>
                <div class="flashcard-face flashcard-back" id="flashcardBack"></div>
            </div>
        </div>
        <div class="progress-info">
            <div id="flashcardProgress"></div>
            <div class="progress-bar">
                <div id="flashcardProgressFill" class="progress-fill"></div>
            </div>
            <div class="difficulty-progress">
                <span>Hard</span>
                <span>Medium</span>
                <span>Easy</span>
                <span>Learnt</span>
                <span>Mastered</span>
            </div>
            <div id="flashcardNextMilestone" class="next-milestone"></div>
        </div>
        <div style="text-align: center; margin-top: 20px;">
            <div class="difficulty-tag hard" onclick="tagWord('hard')">Hard</div>
            <div class="difficulty-tag medium" onclick="tagWord('medium')">Medium</div>
            <div class="difficulty-tag easy" onclick="tagWord('easy')">Easy</div>
            <div class="difficulty-tag learnt" onclick="tagWord('learnt')">Learnt</div>
            <div class="difficulty-tag mastered" onclick="tagWord('mastered')">Mastered</div>
        </div>
        <button onclick="generateFlashcard()">Next Flashcard</button>
        <button class="btn secondary" onclick="hideExercise('flashcardExercise')">Close Exercise</button>
    </div>

    <!-- Matching Exercise -->
    <div id="matchingExercise" class="exercise card" style="display:none">
        <h2 class="card-title">Matching Exercise</h2>
        <div class="score-display">Current Score: <span id="matchingScore">0</span></div>
        <div id="polishWords"></div>
        <div id="englishWords"></div>
        <button onclick="checkMatching()">Check Matches</button>
        <div id="matchingResult" class="result-message"></div>
        <button class="btn secondary" onclick="hideExercise('matchingExercise')">Close Exercise</button>
    </div>

    <!-- Writing Exercise -->
    <div id="writingExercise" class="exercise card" style="display:none">
        <h2 class="card-title">Writing Exercise</h2>
        <div class="score-display">Current Score: <span id="writingScore">0</span></div>
        <img id="writeImage" style="max-width: 300px; display: block; margin: 0 auto;">
        <p>Polish word: <span id="writePolish"></span></p>
        <div class="form-group">
            <input type="text" id="writeAnswer" placeholder="Type English translation...">
        </div>
        <button onclick="checkWriting()">Check Answer</button>
        <div id="writeResult" class="result-message"></div>
        <button class="btn secondary" onclick="hideExercise('writingExercise')">Close Exercise</button>
    </div>

    <!-- Modal Dialogs -->
    <!-- Add Word Modal -->
    <div id="addWordModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Add New Word</h3>
                <button class="modal-close" onclick="closeModal('addWordModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="englishWord">English Word:</label>
                    <input type="text" id="englishWord">
                </div>
                <div class="form-group">
                    <label for="polishWord">Polish Translation:</label>
                    <input type="text" id="polishWord">
                </div>
                <div class="form-group">
                    <label for="imageUrl">Image URL:</label>
                    <input type="text" id="imageUrl">
                    <button class="btn secondary browse-image-btn" id="browseImageBtn">Browse Images</button>
                </div>
                <div class="form-group">
                    <label for="localImage">Or Upload Local Image:</label>
                    <input type="file" id="localImage" accept="image/*">
                </div>
                <div class="form-group">
                    <label for="wordTags">Tags (comma separated):</label>
                    <input type="text" id="wordTags" placeholder="e.g., beginner, food, verbs">
                </div>
                <div class="preview-container">
                    <img id="imagePreview" style="display: none; max-width: 200px; margin-top: 10px;">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn secondary" onclick="closeModal('addWordModal')">Cancel</button>
                <button class="btn" onclick="addWord()">Add Word</button>
            </div>
        </div>
    </div>

    <!-- Edit Word Modal -->
    <div id="editWordModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Edit Word</h3>
                <button class="modal-close" onclick="closeModal('editWordModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="editEnglish">English Word:</label>
                    <input type="text" id="editEnglish">
                </div>
                <div class="form-group">
                    <label for="editPolish">Polish Translation:</label>
                    <input type="text" id="editPolish">
                </div>
                <div class="form-group">
                    <label for="editImageUrl">Image URL:</label>
                    <input type="text" id="editImageUrl">
                    <button class="btn secondary browse-image-btn" id="editBrowseImageBtn">Browse Images</button>
                </div>
                <div class="form-group">
                    <label for="editLocalImage">Or Upload Local Image:</label>
                    <input type="file" id="editLocalImage" accept="image/*">
                </div>
                <div class="form-group">
                    <label for="editTags">Tags (comma separated):</label>
                    <input type="text" id="editTags" placeholder="e.g., beginner, food, verbs">
                </div>
                <div class="preview-container">
                    <img id="editImagePreview" style="display: none; max-width: 200px; margin-top: 10px;">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn secondary" onclick="closeModal('editWordModal')">Cancel</button>
                <button class="btn" onclick="saveEdit()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Achievements Modal -->
    <div id="achievementsModal" class="modal">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h3 class="modal-title">Achievements</h3>
                <button class="modal-close" onclick="closeModal('achievementsModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="achievements-grid" id="achievementsGrid">
                    <!-- Achievement cards will be added here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('achievementsModal')">Close</button>
            </div>
        </div>
    </div>

    <!-- Avatar Selection Modal -->
    <div id="avatarModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Choose Your Avatar</h3>
                <button class="modal-close" onclick="closeModal('avatarModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="avatar-grid" id="avatarGrid">
                    <!-- Avatar options will be added here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('avatarModal')">Close</button>
            </div>
        </div>
    </div>

    <!-- Image Browser Modal -->
    <div id="imageBrowserModal" class="modal">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h3 class="modal-title">Browse Images</h3>
                <button class="modal-close" onclick="closeModal('imageBrowserModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="image-browser-header">
                    <div class="image-search">
                        <input type="text" id="imageSearchInput" placeholder="Search images...">
                        <button id="imageSearchBtn">Search</button>
                    </div>
                    <div class="image-categories" id="imageCategories">
                        <!-- Category buttons will be added here -->
                    </div>
                </div>
                <div class="image-grid" id="imageGrid">
                    <!-- Images will be added here -->
                </div>
                <div class="image-pagination">
                    <button id="prevImagesPage" class="btn secondary">Previous</button>
                    <span id="imagesPageInfo">Page 1 of 1</span>
                    <button id="nextImagesPage" class="btn secondary">Next</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn secondary" onclick="closeModal('imageBrowserModal')">Cancel</button>
                <button class="btn" onclick="ImageBrowser.confirm()">Select Image</button>
            </div>
        </div>
    </div>

    <!-- Onboarding Modal -->
    <div id="onboardingModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Welcome to FlashMasta V10!</h3>
                <button class="modal-close" onclick="completeOnboarding()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="onboarding-step active" data-step="1">
                    <h4>Your Language Learning Journey Begins!</h4>
                    <p>FlashMasta is a powerful tool designed to help you learn vocabulary quickly and effectively using scientifically proven methods.</p>
                </div>
                
                <div class="onboarding-step" data-step="2">
                    <h4>Step 1: Add Your Vocabulary</h4>
                    <p>Start by adding words you want to learn. You can include images to make learning more visual and engaging.</p>
                </div>
                
                <div class="onboarding-step" data-step="3">
                    <h4>Step 2: Practice Regularly</h4>
                    <p>Use different exercise types to practice your vocabulary in various ways. The smart SRS system will help you focus on words that need more practice.</p>
                </div>
                
                <div class="onboarding-step" data-step="4">
                    <h4>Step 3: Track Your Progress</h4>
                    <p>Watch your vocabulary move from "Hard" to "Mastered" as you learn. Earn achievements along the way!</p>
                </div>
                
                <div class="onboarding-step" data-step="5">
                    <h4>Ready to Start?</h4>
                    <p>You're all set! Let's begin adding some vocabulary words.</p>
                    <button class="btn" id="startAddingWordsBtn">Add Your First Words</button>
                </div>
                
                <div class="onboarding-progress">
                    <span class="progress-dot active" data-step="1"></span>
                    <span class="progress-dot" data-step="2"></span>
                    <span class="progress-dot" data-step="3"></span>
                    <span class="progress-dot" data-step="4"></span>
                    <span class="progress-dot" data-step="5"></span>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn secondary" id="onboardingPrevBtn" disabled>Previous</button>
                <button class="btn" id="onboardingNextBtn">Next</button>
                <button class="btn secondary" id="onboardingSkipBtn">Skip Tutorial</button>
            </div>
        </div>
    </div>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
        <div class="achievement-icon"></div>
        <div class="achievement-text">
            <div class="achievement-title">Achievement Unlocked!</div>
            <div class="achievement-name"></div>
        </div>
    </div>

    <!-- Tooltip Container -->
    <div class="tooltip-container" id="tooltipContainer">
        <!-- Tooltips will be added here dynamically -->
    </div>

    <!-- JavaScript -->
    <script>
        /* 
        ==========================================
        CONFIGURATION
        ==========================================
        */
        const AppConfig = {
            // Version info
            version: "10.0",
            dataVersion: "2.0",
            
            // Storage settings
            storage: {
                useGoogleDrive: false,
                localStorageKey: 'flashmasta-data',
                autoSaveInterval: 60000 // milliseconds
            },
            
            // Google API configuration (to be filled by user)
            googleApi: {
                clientId: '', // Fill this in settings
                apiKey: '',   // Fill this in settings
                scopes: 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/drive.appdata',
                discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest']
            },
            
            // UI settings
            ui: {
                primaryColor: '#4a90e2',
                fontSize: 'medium', // small, medium, large
                animationsEnabled: true
            },
            
            // SRS settings
            srs: {
                difficultyLevels: ['hard', 'medium', 'easy', 'learnt', 'mastered'],
                reviewIntervals: {
                    hard: 1, // days
                    medium: 3,
                    easy: 7,
                    learnt: 14,
                    mastered: 30
                }
            },
            
            // Exercise settings
            exercises: {
                minWordsForMatching: 3,
                minWordsForMultipleChoice: 4,
                defaultExerciseScore: 10,
                wrongAnswerPenalty: 5
            }
        };

        /* 
        ==========================================
        EVENT BUS
        ==========================================
        */
        const EventBus = (function() {
            const events = {};
            
            return {
                subscribe: function(event, callback) {
                    if (!events[event]) events[event] = [];
                    events[event].push(callback);
                    return () => this.unsubscribe(event, callback);
                },
                
                publish: function(event, data) {
                    if (!events[event]) return;
                    events[event].forEach(callback => callback(data));
                },
                
                unsubscribe: function(event, callback) {
                    if (!events[event]) return;
                    events[event] = events[event].filter(cb => cb !== callback);
                }
            };
        })();

        /* 
        ==========================================
        MAIN APPLICATION
        ==========================================
        */
        const FlashMastaApp = (function() {
            // Private variables
            let vocabulary = [];
            let currentExercise = null;
            let isDirty = false; // Track if data has changed
            
            // Private methods
            function initAutoSave() {
                setInterval(() => {
                    if (isDirty && StorageManager.isUsingGoogleDrive()) {
                        StorageManager.autoSave()
                            .then(() => {
                                isDirty = false;
                                console.log('Auto-saved to Google Drive');
                            })
                            .catch(error => {
                                console.error('Auto-save failed:', error);
                            });
                    }
                }, AppConfig.storage.autoSaveInterval);
            }
            
            // Public API
            return {
                init: function() {
                    // Subscribe to events
                    EventBus.subscribe('word-added', () => {
                        isDirty = true;
                        this.updateVocabularyDisplay();
                    });
                    
                    EventBus.subscribe('word-edited', () => {
                        isDirty = true;
                        this.updateVocabularyDisplay();
                    });
                    
                    EventBus.subscribe('word-deleted', () => {
                        isDirty = true;
                        this.updateVocabularyDisplay();
                    });
                    
                    EventBus.subscribe('data-imported', () => {
                        this.updateVocabularyDisplay();
                    });
                    
                    // Initialize auto-save
                    initAutoSave();
                    
                    return this;
                },
                
                getVocabulary: function() {
                    return [...vocabulary];
                },
                
                setVocabulary: function(newVocabulary) {
                    vocabulary = newVocabulary;
                    // Initialize SRS for all words
                    vocabulary.forEach(word => {
                        SRSSystem.initWord(word);
                    });
                    isDirty = true;
                    return this;
                },
                
                addWord: function(word) {
                    // Validate word
                    if (!word.english || !word.polish) {
                        throw new Error('Word must have both English and Polish text');
                    }
                    
                    // Initialize difficulty if not set
                    if (!word.difficulty) {
                        word.difficulty = 'medium';
                    }
                    
                    // Initialize tags if not set
                    if (!word.tags) {
                        word.tags = '';
                    }
                    
                    // Initialize nextReview if not set
                    if (!word.nextReview) {
                        word.nextReview = Date.now();
                    }
                    
                    // Initialize SRS
                    SRSSystem.initWord(word);
                    
                    // Add word to vocabulary
                    vocabulary.push(word);
                    
                    // Mark as dirty
                    isDirty = true;
                    
                    // Notify listeners
                    EventBus.publish('word-added', word);
                    
                    return this;
                },
                
                editWord: function(index, updatedWord) {
                    if (index < 0 || index >= vocabulary.length) {
                        throw new Error('Invalid word index');
                    }
                    
                    const oldWord = vocabulary[index];
                    
                    // Handle SRS data migration if English word changed
                    if (oldWord.english !== updatedWord.english) {
                        SRSSystem.migrateWord(oldWord.english, updatedWord.english);
                    }
                    
                    // Update word
                    vocabulary[index] = {
                        ...oldWord,
                        ...updatedWord
                    };
                    
                    // Ensure difficulty is preserved or initialized
                    if (!vocabulary[index].difficulty) {
                        vocabulary[index].difficulty = 'medium';
                    }
                    
                    // Mark as dirty
                    isDirty = true;
                    
                    // Notify listeners
                    EventBus.publish('word-edited', vocabulary[index]);
                    
                    return this;
                },
                
                deleteWord: function(index) {
                    if (index < 0 || index >= vocabulary.length) {
                        throw new Error('Invalid word index');
                    }
                    
                    const word = vocabulary[index];
                    
                    // Remove SRS data
                    SRSSystem.removeWord(word.english);
                    
                    // Remove word
                    vocabulary.splice(index, 1);
                    
                    // Mark as dirty
                    isDirty = true;
                    
                    // Notify listeners
                    EventBus.publish('word-deleted', word);
                    
                    return this;
                },
                
                findWordsByDifficulty: function(difficulty) {
                    if (difficulty === 'all') {
                        return [...vocabulary];
                    }
                    return vocabulary.filter(word => word.difficulty === difficulty);
                },
                
                findWordsByTag: function(tag) {
                    if (tag === 'all') {
                        return [...vocabulary];
                    }
                    return vocabulary.filter(word => {
                        const tags = word.tags.split(',').map(t => t.trim().toLowerCase());
                        return tags.includes(tag.toLowerCase());
                    });
                },
                
                searchWords: function(query) {
                    if (!query) {
                        return [...vocabulary];
                    }
                    
                    query = query.toLowerCase();
                    return vocabulary.filter(word => 
                        word.english.toLowerCase().includes(query) || 
                        word.polish.toLowerCase().includes(query) ||
                        (word.tags && word.tags.toLowerCase().includes(query))
                    );
                },
                
                getAllTags: function() {
                    const tagSet = new Set();
                    vocabulary.forEach(word => {
                        if (word.tags) {
                            const tags = word.tags.split(',').map(t => t.trim());
                            tags.forEach(tag => {
                                if (tag) tagSet.add(tag);
                            });
                        }
                    });
                    return Array.from(tagSet).sort();
                },
                
                getWordCounts: function() {
                    const counts = {
                        total: vocabulary.length,
                        hard: 0,
                        medium: 0,
                        easy: 0,
                        learnt: 0,
                        mastered: 0
                    };
                    
                    vocabulary.forEach(word => {
                        counts[word.difficulty] = (counts[word.difficulty] || 0) + 1;
                    });
                    
                    return counts;
                },
                
                updateVocabularyDisplay: function() {
                    // Update word counts
                    const counts = this.getWordCounts();
                    
                    // Update count displays
                    document.getElementById('countHard').textContent = counts.hard;
                    document.getElementById('countMedium').textContent = counts.medium;
                    document.getElementById('countEasy').textContent = counts.easy;
                    document.getElementById('countLearnt').textContent = counts.learnt;
                    document.getElementById('countMastered').textContent = counts.mastered;
                    
                    // Update mastery counts in progress tab
                    document.getElementById('masteryCountHard').textContent = counts.hard;
                    document.getElementById('masteryCountMedium').textContent = counts.medium;
                    document.getElementById('masteryCountEasy').textContent = counts.easy;
                    document.getElementById('masteryCountLearnt').textContent = counts.learnt;
                    document.getElementById('masteryCountMastered').textContent = counts.mastered;
                    
                    // Update mastered words count
                    document.getElementById('masteredWords').textContent = counts.mastered;
                    document.getElementById('progressMasteredWords').textContent = counts.mastered;
                    
                    // Update progress bars
                    if (counts.total > 0) {
                        const masteryPercent = ((counts.mastered * 5) + (counts.learnt * 4) + (counts.easy * 3) + 
                                             (counts.medium * 2) + (counts.hard)) / (counts.total * 5) * 100;
                        document.getElementById('vocabularyProgressFill').style.width = masteryPercent + '%';
                        document.getElementById('masteryProgressFill').style.width = masteryPercent + '%';
                    } else {
                        document.getElementById('vocabularyProgressFill').style.width = '0%';
                        document.getElementById('masteryProgressFill').style.width = '0%';
                    }
                    
                    // Update tag filter
                    const tagFilter = document.getElementById('tagFilter');
                    const currentTag = tagFilter.value;
                    
                    // Clear existing options
                    tagFilter.innerHTML = '<option value="all">All Tags</option>';
                    
                    // Add tags
                    const tags = this.getAllTags();
                    tags.forEach(tag => {
                        const option = document.createElement('option');
                        option.value = tag;
                        option.textContent = tag;
                        tagFilter.appendChild(option);
                    });
                    
                    // Restore selected tag if possible
                    if (tags.includes(currentTag)) {
                        tagFilter.value = currentTag;
                    }
                    
                    // Update vocabulary list
                    this.updateVocabList();
                    
                    // Check achievements
                    AchievementSystem.updateWordTargets();
                    AchievementSystem.checkAchievements();
                },
                
                updateVocabList: function() {
                    const listDiv = document.getElementById('vocabList');
                    
                    // Get filters
                    const difficultyFilter = document.getElementById('difficultyFilter').value;
                    const tagFilter = document.getElementById('tagFilter').value;
                    const searchQuery = document.getElementById('vocabSearch').value;
                    
                    // Apply filters
                    let filteredVocab = [...vocabulary];
                    
                    if (difficultyFilter !== 'all') {
                        filteredVocab = filteredVocab.filter(word => word.difficulty === difficultyFilter);
                    }
                    
                    if (tagFilter !== 'all') {
                        filteredVocab = filteredVocab.filter(word => {
                            const tags = word.tags.split(',').map(t => t.trim());
                            return tags.includes(tagFilter);
                        });
                    }
                    
                    if (searchQuery) {
                        const query = searchQuery.toLowerCase();
                        filteredVocab = filteredVocab.filter(word => 
                            word.english.toLowerCase().includes(query) || 
                            word.polish.toLowerCase().includes(query)
                        );
                    }
                    
                    // Clear list
                    listDiv.innerHTML = '';
                    
                    // Show message if no words
                    if (filteredVocab.length === 0) {
                        if (vocabulary.length === 0) {
                            listDiv.innerHTML = '<p>No vocabulary words yet. Add some words to get started!</p>';
                        } else {
                            listDiv.innerHTML = '<p>No words match the current filters.</p>';
                        }
                        return;
                    }
                    
                    // Add words to list
                    filteredVocab.forEach((word, index) => {
                        const originalIndex = vocabulary.indexOf(word);
                        
                        const wordDiv = document.createElement('div');
                        wordDiv.className = 'word-item';
                        
                        const detailsDiv = document.createElement('div');
                        detailsDiv.className = 'word-details';
                        
                        const wordText = document.createElement('span');
                        wordText.className = 'word-text';
                        wordText.textContent = word.english;
                        
                        const wordTranslation = document.createElement('span');
                        wordTranslation.className = 'word-translation';
                        wordTranslation.textContent = ' - ' + word.polish;
                        
                        detailsDiv.appendChild(wordText);
                        detailsDiv.appendChild(wordTranslation);
                        
                        // Add tags
                        if (word.tags) {
                            detailsDiv.appendChild(document.createElement('br'));
                            
                            const tags = word.tags.split(',').map(t => t.trim()).filter(t => t);
                            tags.forEach(tag => {
                                const tagSpan = document.createElement('span');
                                tagSpan.className = 'tag';
                                tagSpan.textContent = tag;
                                detailsDiv.appendChild(tagSpan);
                            });
                        }
                        
                        // Add difficulty tag
                        const difficultyTag = document.createElement('span');
                        difficultyTag.className = `tag ${word.difficulty}`;
                        difficultyTag.textContent = word.difficulty;
                        detailsDiv.appendChild(difficultyTag);
                        
                        const actionsDiv = document.createElement('div');
                        actionsDiv.className = 'word-actions';
                        
                        const practiceBtn = document.createElement('button');
                        practiceBtn.className = 'btn small';
                        practiceBtn.textContent = 'Practice';
                        practiceBtn.onclick = () => practiceWord(originalIndex);
                        
                        const editBtn = document.createElement('button');
                        editBtn.className = 'btn small secondary';
                        editBtn.textContent = 'Edit';
                        editBtn.onclick = () => editWord(originalIndex);
                        
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'btn small secondary';
                        deleteBtn.textContent = 'Delete';
                        deleteBtn.onclick = () => deleteWord(originalIndex);
                        
                        actionsDiv.appendChild(practiceBtn);
                        actionsDiv.appendChild(editBtn);
                        actionsDiv.appendChild(deleteBtn);
                        
                        wordDiv.appendChild(detailsDiv);
                        wordDiv.appendChild(actionsDiv);
                        
                        listDiv.appendChild(wordDiv);
                    });
                },
                
                isDirty: function() {
                    return isDirty;
                },
                
                markClean: function() {
                    isDirty = false;
                }
            };
        })();

        /* 
        ==========================================
        SRS SYSTEM
        ==========================================
        */
        const SRSSystem = (function() {
            // Private variables
            let successCounters = {};
            let wordHistory = {};
            const difficultyLevels = AppConfig.srs.difficultyLevels;
            
            // Private methods
            function getNextReviewDate(difficulty) {
                const now = new Date();
                const days = AppConfig.srs.reviewIntervals[difficulty] || 1;
                now.setDate(now.getDate() + days);
                return now.getTime();
            }
            
            // Public API
            return {
                initWord: function(word) {
                    if (!word.difficulty) {
                        word.difficulty = 'medium';
                    }
                    
                    if (!successCounters[word.english]) {
                        successCounters[word.english] = {
                            multipleChoice: 0,
                            writing: 0,
                            consecutive: 0
                        };
                    }
                    
                    if (!wordHistory[word.english]) {
                        wordHistory[word.english] = [];
                    }
                },
                
                migrateWord: function(oldEnglish, newEnglish) {
                    if (successCounters[oldEnglish]) {
                        successCounters[newEnglish] = successCounters[oldEnglish];
                        delete successCounters[oldEnglish];
                    }
                    
                    if (wordHistory[oldEnglish]) {
                        wordHistory[newEnglish] = wordHistory[oldEnglish];
                        delete wordHistory[oldEnglish];
                    }
                },
                
                removeWord: function(english) {
                    delete successCounters[english];
                    delete wordHistory[english];
                },
                
                updateProgressDisplay: function(word, mode) {
                    const progress = document.getElementById(`${mode}Progress`);
                    const progressFill = document.getElementById(`${mode}ProgressFill`);
                    const nextMilestone = document.getElementById(`${mode}NextMilestone`);
                    
                    if (!progress || !progressFill || !nextMilestone) return;
                    
                    const currentLevel = difficultyLevels.indexOf(word.difficulty);
                    const progressPercent = (currentLevel / (difficultyLevels.length - 1)) * 100;
                    
                    progressFill.style.width = `${progressPercent}%`;
                    progress.textContent = `Current level: ${word.difficulty}`;
                    
                    const counters = successCounters[word.english];
                    let milestoneText = '';
                    
                    switch(word.difficulty) {
                        case 'hard':
                            milestoneText = `${3 - counters.multipleChoice} more multiple choice successes needed for 'medium'`;
                            break;
                        case 'medium':
                            if (counters.multipleChoice < 2) {
                                milestoneText = `${2 - counters.multipleChoice} more multiple choice successes needed`;
                            } else {
                                milestoneText = `1 writing success needed for 'easy'`;
                            }
                            break;
                        case 'easy':
                            milestoneText = `${3 - counters.consecutive} more writing successes needed for 'learnt'`;
                            break;
                        case 'learnt':
                            milestoneText = `${3 - counters.consecutive} more writing successes needed for 'mastered'`;
                            break;
                        case 'mastered':
                            milestoneText = 'Mastered! 🎉';
                            break;
                    }
                    
                    nextMilestone.textContent = milestoneText;
                },
                
                shouldUseMultipleChoice: function(word) {
                    this.initWord(word);
                    
                    if (word.difficulty === 'learnt' || word.difficulty === 'mastered' || word.difficulty === 'easy') {
                        return false;
                    }
                    
                    const successes = successCounters[word.english].multipleChoice;
                    
                    if (word.difficulty === 'medium' && successes >= 2) {
                        return false;
                    }
                    
                    if (word.difficulty === 'hard' && successes >= 3) {
                        return false;
                    }
                    
                    const history = wordHistory[word.english];
                    
                    if (history.length > 0) {
                        const lastAttempt = history[history.length - 1];
                        return lastAttempt.type === 'writing' && !lastAttempt.success;
                    }
                    
                    return true;
                },
                
                checkDifficultyProgression: function(word, type, currentStreak) {
                    switch(word.difficulty) {
                        case 'hard':
                            if (type === 'multipleChoice' && currentStreak >= 3) {
                                word.difficulty = 'medium';
                                return true;
                            }
                            break;
                        case 'medium':
                            if (type === 'writing' &&
                                successCounters[word.english].multipleChoice >= 2 &&
                                currentStreak >= 1) {
                                word.difficulty = 'easy';
                                return true;
                            }
                            break;
                        case 'easy':
                            if (type === 'writing' && currentStreak >= 3) {
                                word.difficulty = 'learnt';
                                return true;
                            }
                            break;
                        case 'learnt':
                            if (type === 'writing' && currentStreak >= 3) {
                                word.difficulty = 'mastered';
                                return true;
                            }
                            break;
                    }
                    
                    return false;
                },
                
                checkDifficultyRegression: function(word, type, failures) {
                    const currentLevel = difficultyLevels.indexOf(word.difficulty);
                    
                    if (currentLevel <= 0) return false;
                    
                    let shouldRegress = false;
                    
                    if (type === 'writing' && failures === 1) {
                        shouldRegress = true;
                    } else if (type === 'multipleChoice' && failures >= 2) {
                        shouldRegress = true;
                    }
                    
                    if (shouldRegress) {
                        word.difficulty = difficultyLevels[currentLevel - 1];
                        successCounters[word.english].multipleChoice = 0;
                        successCounters[word.english].writing = 0;
                        successCounters[word.english].consecutive = 0;
                        return true;
                    }
                    
                    return false;
                },
                
                recordAttempt: function(word, type, success) {
                    this.initWord(word);
                    
                    if (success) {
                        successCounters[word.english][type]++;
                        successCounters[word.english].consecutive++;
                        
                        if (this.checkDifficultyProgression(word, type, successCounters[word.english].consecutive)) {
                            successCounters[word.english].multipleChoice = 0;
                            successCounters[word.english].writing = 0;
                            successCounters[word.english].consecutive = 0;
                            
                            // Update next review date
                            word.nextReview = getNextReviewDate(word.difficulty);
                        }
                    } else {
                        const history = wordHistory[word.english];
                        const recentFailures = history
                            .slice(-2)
                            .filter(h => h.type === type && !h.success)
                            .length + 1;
                            
                        this.checkDifficultyRegression(word, type, recentFailures);
                        successCounters[word.english].consecutive = 0;
                        
                        // Update next review date to review sooner
                        word.nextReview = Date.now() + (1000 * 60 * 60 * 24); // Tomorrow
                    }
                    
                    wordHistory[word.english].push({
                        type,
                        success,
                        timestamp: Date.now(),
                        newDifficulty: word.difficulty
                    });
                },
                
                getDueWords: function() {
                    const now = Date.now();
                    return FlashMastaApp.getVocabulary().filter(word => !word.nextReview || word.nextReview <= now);
                },
                
                getSuccessCounters: function() {
                    return successCounters;
                },
                
                getWordHistory: function() {
                    return wordHistory;
                },
                
                setSuccessCounters: function(newCounters) {
                    successCounters = newCounters;
                },
                
                setWordHistory: function(newHistory) {
                    wordHistory = newHistory;
                }
            };
        })();

        /* 
        ==========================================
        ACHIEVEMENT SYSTEM
        ==========================================
        */
        const AchievementSystem = (function() {
            // Private variables
            let achievements = [
                {
                    id: 'word_master_bronze',
                    name: 'Word Master Bronze',
                    description: 'Get all words to at least medium difficulty',
                    icon: '🥉',
                    type: 'progress',
                    level: 1,
                    progress: 0,
                    target: null, // Set dynamically based on vocabulary size
                    achieved: false,
                    dateAchieved: null
                },
                {
                    id: 'word_master_silver',
                    name: 'Word Master Silver',
                    description: 'Get all words to at least easy difficulty',
                    icon: '🥈',
                    type: 'progress',
                    level: 2,
                    progress: 0,
                    target: null,
                    achieved: false,
                    dateAchieved: null
                },
                {
                    id: 'word_master_gold',
                    name: 'Word Master Gold',
                    description: 'Get all words to at least learnt difficulty',
                    icon: '🥇',
                    type: 'progress',
                    level: 3,
                    progress: 0,
                    target: null,
                    achieved: false,
                    dateAchieved: null
                },
                {
                    id: 'perfect_recall_bronze',
                    name: 'Perfect Recall Bronze',
                    description: '3 consecutive writing successes',
                    icon: '📝',
                    type: 'performance',
                    level: 1,
                    progress: 0,
                    target: 3,
                    achieved: false,
                    dateAchieved: null
                },
                {
                    id: 'perfect_recall_silver',
                    name: 'Perfect Recall Silver',
                    description: '5 consecutive writing successes',
                    icon: '✍️',
                    type: 'performance',
                    level: 2,
                    progress: 0,
                    target: 5,
                    achieved: false,
                    dateAchieved: null
                },
                {
                    id: 'perfect_recall_gold',
                    name: 'Perfect Recall Gold',
                    description: '10 consecutive writing successes',
                    icon: '🏆',
                    type: 'performance',
                    level: 3,
                    progress: 0,
                    target: 10,
                    achieved: false,
                    dateAchieved: null
                },
                {
                    id: 'speed_demon_bronze',
                    name: 'Speed Demon Bronze',
                    description: 'Complete 5 words under 30 seconds each',
                    icon: '⚡',
                    type: 'speed',
                    level: 1,
                    progress: 0,
                    target: 5,
                    achieved: false,
                    dateAchieved: null
                },
                {
                    id: 'explorer',
                    name: 'Explorer',
                    description: 'Try all exercise types',
                    icon: '🌟',
                    type: 'special',
                    level: 1,
                    progress: 0,
                    target: 6,
                    achieved: false,
                    dateAchieved: null,
                    exercisesTried: new Set()
                },
                {
                    id: 'vocabulary_builder_bronze',
                    name: 'Vocabulary Builder Bronze',
                    description: 'Add 10 words to your vocabulary',
                    icon: '📚',
                    type: 'progress',
                    level: 1,
                    progress: 0,
                    target: 10,
                    achieved: false,
                    dateAchieved: null
                },
                {
                    id: 'vocabulary_builder_silver',
                    name: 'Vocabulary Builder Silver',
                    description: 'Add 25 words to your vocabulary',
                    icon: '📚',
                    type: 'progress',
                    level: 2,
                    progress: 0,
                    target: 25,
                    achieved: false,
                    dateAchieved: null
                },
                {
                    id: 'vocabulary_builder_gold',
                    name: 'Vocabulary Builder Gold',
                    description: 'Add 50 words to your vocabulary',
                    icon: '📚',
                    type: 'progress',
                    level: 3,
                    progress: 0,
                    target: 50,
                    achieved: false,
                    dateAchieved: null
                },
                {
                    id: 'mastery_champion',
                    name: 'Mastery Champion',
                    description: 'Master 10 words',
                    icon: '👑',
                    type: 'progress',
                    level: 2,
                    progress: 0,
                    target: 10,
                    achieved: false,
                    dateAchieved: null
                }
            ];
            
            // Private methods
            function countWordsAboveDifficulty(minDifficulty) {
                const difficultyLevels = AppConfig.srs.difficultyLevels;
                const minIndex = difficultyLevels.indexOf(minDifficulty);
                
                return FlashMastaApp.getVocabulary().filter(word => {
                    const wordIndex = difficultyLevels.indexOf(word.difficulty);
                    return wordIndex > minIndex;
                }).length;
            }
            
            // Public API
            return {
                init: function() {
                    this.updateWordTargets();
                    this.checkAchievements();
                    return this;
                },
                
                updateWordTargets: function() {
                    const vocabulary = FlashMastaApp.getVocabulary();
                    const vocabSize = vocabulary.length;
                    
                    achievements.forEach(achievement => {
                        if (achievement.id.startsWith('word_master_')) {
                            achievement.target = vocabSize;
                            achievement.progress = this.countWordsAboveDifficulty(
                                achievement.id === 'word_master_bronze' ? 'hard' :
                                achievement.id === 'word_master_silver' ? 'medium' : 'easy'
                            );
                        } else if (achievement.id.startsWith('vocabulary_builder_')) {
                            achievement.progress = vocabSize;
                        } else if (achievement.id === 'mastery_champion') {
                            achievement.progress = vocabulary.filter(word => word.difficulty === 'mastered').length;
                        }
                    });
                },
                
                countWordsAboveDifficulty: function(minDifficulty) {
                    return countWordsAboveDifficulty(minDifficulty);
                },
                
                checkAchievements: function() {
                    achievements.forEach(achievement => {
                        // Skip Word Master achievements if vocabulary is empty
                        if (achievement.id.startsWith('word_master_') && FlashMastaApp.getVocabulary().length === 0) {
                            return;
                        }
                        
                        if (!achievement.achieved && achievement.target !== null && achievement.progress >= achievement.target) {
                            this.unlockAchievement(achievement);
                        }
                    });
                },
                
                unlockAchievement: function(achievement) {
                    achievement.achieved = true;
                    achievement.dateAchieved = new Date();
                    this.showUnlockNotification(achievement);
                    
                    // Notify listeners
                    EventBus.publish('achievement-unlocked', achievement);
                },
                
                showUnlockNotification: function(achievement) {
                    const notification = document.getElementById('achievementNotification');
                    const icon = notification.querySelector('.achievement-icon');
                    const name = notification.querySelector('.achievement-name');
                    
                    icon.textContent = achievement.icon;
                    name.textContent = achievement.name;
                    
                    notification.classList.add('show');
                    icon.classList.add('celebrating');
                    
                    setTimeout(() => {
                        notification.classList.remove('show');
                        icon.classList.remove('celebrating');
                    }, 3000);
                },
                
                recordWritingSuccess: function(consecutive) {
                    achievements
                        .filter(a => a.id.startsWith('perfect_recall_'))
                        .forEach(a => {
                            a.progress = consecutive;
                            this.checkAchievements();
                        });
                },
                
                recordExerciseAttempt: function(type) {
                    const explorer = achievements.find(a => a.id === 'explorer');
                    
                    if (explorer && !explorer.exercisesTried.has(type)) {
                        explorer.exercisesTried.add(type);
                        explorer.progress = explorer.exercisesTried.size;
                        this.checkAchievements();
                    }
                },
                
                getAllAchievements: function() {
                    return achievements;
                },
                
                setAchievements: function(newAchievements) {
                    // Handle old achievements without exercisesTried
                    newAchievements.forEach(achievement => {
                        if (achievement.id === 'explorer' && !achievement.exercisesTried) {
                            achievement.exercisesTried = new Set();
                        } else if (achievement.id === 'explorer' && Array.isArray(achievement.exercisesTried)) {
                            achievement.exercisesTried = new Set(achievement.exercisesTried);
                        }
                    });
                    
                    achievements = newAchievements;
                }
            };
        })();

        /* 
        ==========================================
        AVATAR SYSTEM
        ==========================================
        */
        const AvatarSystem = (function() {
            // Private variables
            const avatarStyles = [
                { style: 'micah', name: 'Micah', seed: 'default' },
                { style: 'big-smile', name: 'Big Smile', seed: null },
                { style: 'pixel-art', name: 'Pixel Art', seed: null },
                { style: 'bottts', name: 'Bottts', seed: null },
                { style: 'lorelei', name: 'Lorelei', seed: null },
                { style: 'personas', name: 'Personas', seed: null },
                { style: 'adventurer', name: 'Adventurer', seed: 'Avery' },
                { style: 'open-peeps', name: 'Open Peeps', seed: null },
                { style: 'thumbs', name: 'Thumbs', seed: null },
                { style: 'avataaars', name: 'Avataaars', seed: null },
                { style: 'croodles', name: 'Croodles', seed: null },
                { style: 'big-ears', name: 'Big Ears', seed: 'Andrea' }
            ];
            
            let current = {
                style: 'micah',
                seed: 'default',
                name: 'Default Avatar'
            };
            
            // Public API
            return {
                init: function() {
                    this.updateAvatar();
                    this.updateWordCounts();
                    return this;
                },
                
                getAvatarStyles: function() {
                    return avatarStyles;
                },
                
                getCurrent: function() {
                    return current;
                },
                
                setCurrent: function(avatar) {
                    current = avatar;
                    this.updateAvatar();
                },
                
                updateAvatar: function() {
                    const baseUrl = `https://api.dicebear.com/9.x/${current.style}/svg`;
                    const params = current.seed ? `?seed=${current.seed}` : '';
                    document.getElementById('currentAvatar').src = baseUrl + params;
                },
                
                updateWordCounts: function() {
                    const counts = FlashMastaApp.getWordCounts();
                    
                    // Update count display
                    document.querySelector('.count-mastered').textContent = counts.mastered || 0;
                    document.querySelector('.count-learnt').textContent = counts.learnt || 0;
                    document.querySelector('.count-easy').textContent = counts.easy || 0;
                    document.querySelector('.count-medium').textContent = counts.medium || 0;
                    document.querySelector('.count-hard').textContent = counts.hard || 0;
                },
                
                populateAvatarGrid: function() {
                    const grid = document.getElementById('avatarGrid');
                    
                    // Clear grid
                    grid.innerHTML = '';
                    
                    // Add avatar options
                    avatarStyles.forEach(avatar => {
                        const option = document.createElement('div');
                        option.className = 'avatar-option';
                        
                        if (avatar.style === current.style && avatar.seed === current.seed) {
                            option.classList.add('selected');
                        }
                        
                        const baseUrl = `https://api.dicebear.com/9.x/${avatar.style}/svg`;
                        const params = avatar.seed ? `?seed=${avatar.seed}` : '';
                        
                        option.innerHTML = `
                            <img src="${baseUrl}${params}" alt="${avatar.name}">
                            <div class="avatar-name">${avatar.name}</div>
                        `;
                        
                        option.addEventListener('click', () => {
                            // Update current avatar
                            current = { 
                                style: avatar.style, 
                                seed: avatar.seed,
                                name: avatar.name
                            };
                            
                            // Update selected class
                            document.querySelectorAll('.avatar-option').forEach(opt => {
                                opt.classList.remove('selected');
                            });
                            
                            option.classList.add('selected');
                            
                            // Update avatar display
                            this.updateAvatar();
                        });
                        
                        grid.appendChild(option);
                    });
                }
            };
        })();

        /* 
        ==========================================
        STORAGE MANAGER
        ==========================================
        */
        const StorageManager = (function() {
            // Private variables
            let googleDriveAvailable = false;
            
            // Public API
            return {
                init: async function(useGoogleDrive = false) {
                    AppConfig.storage.useGoogleDrive = useGoogleDrive;
                    
                    if (useGoogleDrive) {
                        try {
                            await GoogleDriveAPI.init();
                            googleDriveAvailable = true;
                        } catch (error) {
                            console.error('Google Drive initialization failed:', error);
                            AppConfig.storage.useGoogleDrive = false;
                            googleDriveAvailable = false;
                        }
                    }
                    
                    return this;
                },
                
                isUsingGoogleDrive: function() {
                    return AppConfig.storage.useGoogleDrive && googleDriveAvailable;
                },
                
                saveToFile: async function(filename) {
                    const data = this.prepareDataForSave();
                    
                    if (this.isUsingGoogleDrive()) {
                        try {
                            await GoogleDriveAPI.saveFile(filename || 'flashmasta_vocabulary.json', JSON.stringify(data, this.serializer));
                            FlashMastaApp.markClean();
                            return true;
                        } catch (error) {
                            console.error('Failed to save to Google Drive:', error);
                            
                            if (confirm('Failed to save to Google Drive. Would you like to download the file instead?')) {
                                this.downloadFile(data, filename || 'flashmasta_vocabulary.json');
                            }
                            
                            return false;
                        }
                    } else {
                        this.downloadFile(data, filename || 'flashmasta_vocabulary.json');
                        FlashMastaApp.markClean();
                        return true;
                    }
                },
                
                downloadFile: function(data, filename) {
                    const jsonString = JSON.stringify(data, this.serializer, 2);
                    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(jsonString);
                    
                    const link = document.createElement('a');
                    link.setAttribute('href', dataUri);
                    link.setAttribute('download', filename);
                    link.style.display = 'none';
                    
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                },
                
                loadFromFile: async function(fileOrPath) {
                    let jsonString;
                    
                    if (this.isUsingGoogleDrive() && typeof fileOrPath === 'string') {
                        try {
                            jsonString = await GoogleDriveAPI.loadFile(fileOrPath);
                        } catch (error) {
                            console.error('Failed to load from Google Drive:', error);
                            alert('Failed to load file from Google Drive: ' + error.message);
                            return false;
                        }
                    } else if (fileOrPath instanceof HTMLInputElement && fileOrPath.files && fileOrPath.files[0]) {
                        const file = fileOrPath.files[0];
                        
                        try {
                            jsonString = await new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                
                                reader.onload = function(e) {
                                    resolve(e.target.result);
                                };
                                
                                reader.onerror = function() {
                                    reject(new Error('Failed to read file'));
                                };
                                
                                reader.readAsText(file);
                            });
                        } catch (error) {
                            console.error('Failed to read local file:', error);
                            alert('Failed to read file: ' + error.message);
                            return false;
                        }
                    } else {
                        console.error('Invalid file or path provided');
                        return false;
                    }
                    
                    try {
                        const data = JSON.parse(jsonString, this.deserializer);
                        return this.loadDataFromObject(data);
                    } catch (error) {
                        console.error('Error parsing JSON:', error);
                        alert('Error parsing file: ' + error.message);
                        return false;
                    }
                },
                
                loadDataFromObject: function(data) {
                    // Validate and ensure data structure is correct
                    if (!data.version) {
                        data.version = "1.0"; // Assume older version
                    }
                    
                    // Handle data version migrations if needed
                    if (data.version !== AppConfig.dataVersion) {
                        data = this.migrateData(data);
                    }
                    
                    // Load vocabulary
                    if (data.vocabulary) {
                        FlashMastaApp.setVocabulary(data.vocabulary);
                    } else {
                        FlashMastaApp.setVocabulary([]);
                    }
                    
                    // Load scores
                    if (data.scores) {
                        Scores.setAll(data.scores);
                    }
                    
                    // Load SRS data
                    if (data.srs) {
                        if (data.srs.successCounters) {
                            SRSSystem.setSuccessCounters(data.srs.successCounters);
                        }
                        
                        if (data.srs.wordHistory) {
                            SRSSystem.setWordHistory(data.srs.wordHistory);
                        }
                    }
                    
                    // Load avatar
                    if (data.avatar) {
                        AvatarSystem.setCurrent(data.avatar);
                    }
                    
                    // Load achievements
                    if (data.achievements) {
                        AchievementSystem.setAchievements(data.achievements);
                    }
                    
                    // Update UI
                    updateScores();
                    FlashMastaApp.updateVocabularyDisplay();
                    AvatarSystem.updateAvatar();
                    AvatarSystem.updateWordCounts();
                    
                    // Notify listeners
                    EventBus.publish('data-imported', data);
                    
                    return true;
                },
                
                prepareDataForSave: function() {
                    return {
                        version: AppConfig.dataVersion,
                        vocabulary: FlashMastaApp.getVocabulary(),
                        scores: Scores.getAll(),
                        avatar: AvatarSystem.getCurrent(),
                        achievements: AchievementSystem.getAllAchievements(),
                        srs: {
                            successCounters: SRSSystem.getSuccessCounters(),
                            wordHistory: SRSSystem.getWordHistory()
                        }
                    };
                },
                
                autoSave: async function() {
                    if (!this.isUsingGoogleDrive()) {
                        return false;
                    }
                    
                    const data = this.prepareDataForSave();
                    const filename = 'flashmasta_autosave.json';
                    
                    try {
                        await GoogleDriveAPI.saveFile(filename, JSON.stringify(data, this.serializer));
                        FlashMastaApp.markClean();
                        return true;
                    } catch (error) {
                        console.error('Auto-save failed:', error);
                        return false;
                    }
                },
                
                migrateData: function(data) {
                    const sourceVersion = data.version;
                    const targetVersion = AppConfig.dataVersion;
                    
                    console.log(`Migrating data from version ${sourceVersion} to ${targetVersion}`);
                    
                    // Example migration logic
                    if (sourceVersion === "1.0" && targetVersion === "2.0") {
                        // Add difficulty field to words if missing
                        if (data.vocabulary) {
                            data.vocabulary.forEach(word => {
                                if (!word.difficulty) word.difficulty = "medium";
                                if (!word.tags) word.tags = "";
                                if (!word.nextReview) word.nextReview = Date.now();
                            });
                        }
                        
                        // Update version
                        data.version = "2.0";
                    }
                    
                    return data;
                },
                
                // Serialize/deserialize helpers
                serializer: function(key, value) {
                    // Convert Sets to arrays for JSON serialization
                    if (value instanceof Set) {
                        return {
                            _type: 'Set',
                            values: Array.from(value)
                        };
                    }
                    return value;
                },
                
                deserializer: function(key, value) {
                    // Convert arrays back to Sets during deserialization
                    if (value && typeof value === 'object' && value._type === 'Set') {
                        return new Set(value.values);
                    }
                    return value;
                }
            };
        })();

        /* 
        ==========================================
        GOOGLE DRIVE API
        ==========================================
        */
        const GoogleDriveAPI = (function() {
            // Private variables
            const APP_FOLDER_NAME = 'FlashMasta Data';
            const IMAGES_FOLDER_NAME = 'FlashMasta Images';
            
            let appFolderId = null;
            let imagesFolderId = null;
            let tokenClient;
            let isAuthenticated = false;
            
            // Private methods
            async function initClient() {
                if (!AppConfig.googleApi.clientId || !AppConfig.googleApi.apiKey) {
                    throw new Error('Google API credentials not set. Please configure in settings.');
                }
                
                await new Promise((resolve) => gapi.load('client', resolve));
                
                await gapi.client.init({
                    apiKey: AppConfig.googleApi.apiKey,
                    discoveryDocs: AppConfig.googleApi.discoveryDocs,
                });
                
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: AppConfig.googleApi.clientId,
                    scope: AppConfig.googleApi.scopes,
                    callback: '', // defined later
                });
                
                // Check if already authenticated
                if (gapi.client.getToken() !== null) {
                    isAuthenticated = true;
                    await ensureAppFolder();
                }
            }
            
            async function authenticate() {
                return new Promise((resolve, reject) => {
                    tokenClient.callback = async (resp) => {
                        if (resp.error !== undefined) {
                            reject(resp);
                            return;
                        }
                        
                        isAuthenticated = true;
                        
                        try {
                            await ensureAppFolder();
                            resolve();
                        } catch (error) {
                            reject(error);
                        }
                    };
                    
                    if (gapi.client.getToken() === null) {
                        // Request a token
                        tokenClient.requestAccessToken({ prompt: 'consent' });
                    } else {
                        // Skip token request if already have one
                        tokenClient.requestAccessToken({ prompt: '' });
                    }
                });
            }
            
            async function ensureAppFolder() {
                // Look for existing app folder
                const response = await gapi.client.drive.files.list({
                    q: `name='${APP_FOLDER_NAME}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                    spaces: 'drive',
                    fields: 'files(id, name)'
                });
                
                const files = response.result.files;
                
                if (files && files.length > 0) {
                    // Use existing folder
                    appFolderId = files[0].id;
                } else {
                    // Create new folder
                    const fileMetadata = {
                        'name': APP_FOLDER_NAME,
                        'mimeType': 'application/vnd.google-apps.folder'
                    };
                    
                    const folderResponse = await gapi.client.drive.files.create({
                        resource: fileMetadata,
                        fields: 'id'
                    });
                    
                    appFolderId = folderResponse.result.id;
                }
                
                // Ensure images folder exists
                await ensureImagesFolder();
            }
            
            async function ensureImagesFolder() {
                // Check if app folder exists
                if (!appFolderId) {
                    throw new Error('App folder not found');
                }
                
                // Look for existing images folder
                const response = await gapi.client.drive.files.list({
                    q: `name='${IMAGES_FOLDER_NAME}' and '${appFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                    spaces: 'drive',
                    fields: 'files(id, name)'
                });
                
                const files = response.result.files;
                
                if (files && files.length > 0) {
                    // Use existing folder
                    imagesFolderId = files[0].id;
                } else {
                    // Create new folder
                    const fileMetadata = {
                        'name': IMAGES_FOLDER_NAME,
                        'parents': [appFolderId],
                        'mimeType': 'application/vnd.google-apps.folder'
                    };
                    
                    const folderResponse = await gapi.client.drive.files.create({
                        resource: fileMetadata,
                        fields: 'id'
                    });
                    
                    imagesFolderId = folderResponse.result.id;
                }
            }
            
            async function findFile(filename, folderId) {
                if (!folderId) {
                    folderId = appFolderId;
                }
                
                const response = await gapi.client.drive.files.list({
                    q: `name='${filename}' and '${folderId}' in parents and trashed=false`,
                    spaces: 'drive',
                    fields: 'files(id, name)'
                });
                
                const files = response.result.files;
                return files && files.length > 0 ? files[0].id : null;
            }
            
            // Public API
            return {
                init: async function() {
                    try {
                        await initClient();
                        console.log('Google Drive API initialized');
                        return true;
                    } catch (error) {
                        console.error('Error initializing Google Drive API:', error);
                        throw error;
                    }
                },
                
                login: async function() {
                    if (isAuthenticated) return true;
                    
                    try {
                        await authenticate();
                        return true;
                    } catch (error) {
                        console.error('Google authentication error:', error);
                        throw error;
                    }
                },
                
                logout: function() {
                    const token = gapi.client.getToken();
                    
                    if (token !== null) {
                        google.accounts.oauth2.revoke(token.access_token);
                        gapi.client.setToken('');
                        isAuthenticated = false;
                        appFolderId = null;
                        imagesFolderId = null;
                    }
                },
                
                isLoggedIn: function() {
                    return isAuthenticated;
                },
                
                saveFile: async function(filename, content) {
                    if (!isAuthenticated) {
                        await this.login();
                    }
                    
                    if (!appFolderId) {
                        await ensureAppFolder();
                    }
                    
                    const existingFileId = await findFile(filename);
                    const contentBlob = new Blob([content], { type: 'application/json' });
                    
                    const metadata = {
                        'name': filename,
                        'mimeType': 'application/json'
                    };
                    
                    if (!existingFileId) {
                        // Add parent folder ID if creating new file
                        metadata.parents = [appFolderId];
                        
                        // Upload new file
                        const form = new FormData();
                        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                        form.append('file', contentBlob);
                        
                        const requestOptions = {
                            method: 'POST',
                            headers: new Headers({ 'Authorization': 'Bearer ' + gapi.client.getToken().access_token }),
                            body: form
                        };
                        
                        try {
                            const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', requestOptions);
                            return response.ok;
                        } catch (error) {
                            console.error('Error saving file to Google Drive:', error);
                            throw error;
                        }
                    } else {
                        // Update existing file
                        const form = new FormData();
                        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                        form.append('file', contentBlob);
                        
                        const requestOptions = {
                            method: 'PATCH',
                            headers: new Headers({ 'Authorization': 'Bearer ' + gapi.client.getToken().access_token }),
                            body: form
                        };
                        
                        try {
                            const response = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${existingFileId}?uploadType=multipart`, requestOptions);
                            return response.ok;
                        } catch (error) {
                            console.error('Error updating file on Google Drive:', error);
                            throw error;
                        }
                    }
                },
                
                loadFile: async function(filename) {
                    if (!isAuthenticated) {
                        await this.login();
                    }
                    
                    const fileId = await findFile(filename);
                    
                    if (!fileId) {
                        throw new Error(`File ${filename} not found on Google Drive`);
                    }
                    
                    try {
                        const response = await gapi.client.drive.files.get({
                            fileId: fileId,
                            alt: 'media'
                        });
                        
                        return response.body;
                    } catch (error) {
                        console.error('Error loading file from Google Drive:', error);
                        throw error;
                    }
                },
                
                listFiles: async function() {
                    if (!isAuthenticated) {
                        await this.login();
                    }
                    
                    if (!appFolderId) {
                        await ensureAppFolder();
                    }
                    
                    try {
                        const response = await gapi.client.drive.files.list({
                            q: `'${appFolderId}' in parents and trashed=false`,
                            spaces: 'drive',
                            fields: 'files(id, name, modifiedTime, size, mimeType)',
                            orderBy: 'modifiedTime desc'
                        });
                        
                        return response.result.files || [];
                    } catch (error) {
                        console.error('Error listing files from Google Drive:', error);
                        throw error;
                    }
                },
                
                deleteFile: async function(fileId) {
                    if (!isAuthenticated) {
                        await this.login();
                    }
                    
                    try {
                        await gapi.client.drive.files.delete({
                            fileId: fileId
                        });
                        
                        return true;
                    } catch (error) {
                        console.error('Error deleting file from Google Drive:', error);
                        throw error;
                    }
                },
                
                getAppFolderId: function() {
                    return appFolderId;
                },
                
                getImagesFolderId: function() {
                    return imagesFolderId;
                },
                
                uploadImage: async function(file, category = '') {
                    if (!file) {
                        throw new Error('No file provided');
                    }
                    
                    // Validate file type
                    if (!file.type.startsWith('image/')) {
                        throw new Error('File must be an image');
                    }
                    
                    if (!isAuthenticated) {
                        await this.login();
                    }
                    
                    if (!imagesFolderId) {
                        await ensureImagesFolder();
                    }
                    
                    // Prepare file name with category if provided
                    let fileName = file.name;
                    
                    if (category) {
                        // Add category to filename if not already present
                        if (!fileName.includes(`[${category}]`)) {
                            const nameParts = fileName.split('.');
                            const ext = nameParts.pop();
                            fileName = `${nameParts.join('.')}[${category}].${ext}`;
                        }
                    }
                    
                    // Upload file
                    const metadata = {
                        'name': fileName,
                        'parents': [imagesFolderId]
                    };
                    
                    const form = new FormData();
                    form.append('metadata', new Blob([JSON.stringify(metadata)], {type: 'application/json'}));
                    form.append('file', file);
                    
                    const accessToken = gapi.client.getToken().access_token;
                    
                    try {
                        const response = await fetch(
                            'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                            method: 'POST',
                            headers: new Headers({'Authorization': 'Bearer ' + accessToken}),
                            body: form
                        });
                        
                        if (!response.ok) {
                            throw new Error('Failed to upload image');
                        }
                        
                        const result = await response.json();
                        return result.id;
                    } catch (error) {
                        console.error('Error uploading image:', error);
                        throw error;
                    }
                }
            };
        })();

        /* 
        ==========================================
        IMAGE BROWSER
        ==========================================
        */
        const ImageBrowser = (function() {
            // Private variables
            let currentImages = [];
            let currentPage = 1;
            let totalPages = 1;
            let pageSize = 16;
            let currentCategory = 'all';
            let searchQuery = '';
            let selectedImageUrl = '';
            let selectedImageId = '';
            let onImageSelectCallback = null;
            
            // Private methods
            async function fetchImages() {
                if (!GoogleDriveAPI.isLoggedIn()) {
                    try {
                        await GoogleDriveAPI.login();
                    } catch (error) {
                        console.error('Failed to log in to Google Drive:', error);
                        return [];
                    }
                }
                
                const imagesFolderId = GoogleDriveAPI.getImagesFolderId();
                
                if (!imagesFolderId) {
                    throw new Error('Images folder not found');
                }
                
                // Build query
                let query = `'${imagesFolderId}' in parents and trashed=false and (mimeType contains 'image/')`;
                
                if (searchQuery) {
                    query += ` and name contains '${searchQuery}'`;
                }
                
                if (currentCategory !== 'all') {
                    query += ` and name contains '[${currentCategory}]'`;
                }
                
                try {
                    const response = await gapi.client.drive.files.list({
                        q: query,
                        spaces: 'drive',
                        fields: 'files(id, name, thumbnailLink, webContentLink)',
                        orderBy: 'modifiedTime desc'
                    });
                    
                    const files = response.result.files || [];
                    
                    // Process files and generate direct download URLs
                    const processedFiles = await Promise.all(files.map(async file => {
                        let downloadUrl = file.thumbnailLink || '';
                        
                        // Get the web content link (direct download)
                        if (file.webContentLink) {
                            downloadUrl = file.webContentLink.replace('&export=download', '');
                        }
                        
                        return {
                            id: file.id,
                            name: file.name,
                            thumbnail: file.thumbnailLink || downloadUrl,
                            url: downloadUrl
                        };
                    }));
                    
                    return processedFiles;
                } catch (error) {
                    console.error('Error fetching images from Google Drive:', error);
                    return [];
                }
            }
            
            function renderImageGrid(images) {
                const imageGrid = document.getElementById('imageGrid');
                imageGrid.innerHTML = '';
                
                if (images.length === 0) {
                    imageGrid.innerHTML = '<div class="no-images-message">No images found. Try a different search or category.</div>';
                    return;
                }
                
                // Calculate pagination
                totalPages = Math.ceil(images.length / pageSize);
                
                if (currentPage > totalPages) {
                    currentPage = totalPages;
                }
                
                // Update pagination UI
                document.getElementById('imagesPageInfo').textContent = `Page ${currentPage} of ${totalPages}`;
                document.getElementById('prevImagesPage').disabled = currentPage <= 1;
                document.getElementById('nextImagesPage').disabled = currentPage >= totalPages;
                
                // Slice images for current page
                const startIdx = (currentPage - 1) * pageSize;
                const endIdx = Math.min(startIdx + pageSize, images.length);
                const pageImages = images.slice(startIdx, endIdx);
                
                // Render images
                pageImages.forEach(image => {
                    const imageItem = document.createElement('div');
                    imageItem.className = 'image-item';
                    imageItem.dataset.imageId = image.id;
                    imageItem.dataset.imageUrl = image.url;
                    
                    if (image.id === selectedImageId) {
                        imageItem.classList.add('selected');
                    }
                    
                    const img = document.createElement('img');
                    img.src = image.thumbnail;
                    img.alt = image.name;
                    img.loading = 'lazy';
                    
                    imageItem.appendChild(img);
                    imageItem.addEventListener('click', () => selectImage(imageItem));
                    
                    imageGrid.appendChild(imageItem);
                });
            }
            
            function selectImage(imageItem) {
                // Clear previous selection
                document.querySelectorAll('.image-item.selected').forEach(item => {
                    item.classList.remove('selected');
                });
                
                // Select current image
                imageItem.classList.add('selected');
                selectedImageUrl = imageItem.dataset.imageUrl;
                selectedImageId = imageItem.dataset.imageId;
            }
            
            function loadCategories() {
                // Extract categories from image names
                const categorySet = new Set(['all']);
                
                currentImages.forEach(image => {
                    const match = image.name.match(/\[([^\]]+)\]/);
                    if (match && match[1]) {
                        categorySet.add(match[1]);
                    }
                });
                
                // Render category buttons
                const categoriesContainer = document.getElementById('imageCategories');
                categoriesContainer.innerHTML = '';
                
                Array.from(categorySet).sort().forEach(category => {
                    const button = document.createElement('button');
                    button.className = `category-btn ${category === currentCategory ? 'active' : ''}`;
                    button.textContent = category === 'all' ? 'All Categories' : category;
                    button.addEventListener('click', () => {
                        // Update selected category
                        currentCategory = category;
                        
                        // Update UI
                        document.querySelectorAll('.category-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        
                        button.classList.add('active');
                        
                        // Reset page
                        currentPage = 1;
                        
                        // Refresh images
                        refresh();
                    });
                    
                    categoriesContainer.appendChild(button);
                });
            }
            
            function search() {
                searchQuery = document.getElementById('imageSearchInput').value.trim();
                currentPage = 1;
                refresh();
            }
            
            function refresh() {
                fetchImages()
                    .then(images => {
                        currentImages = images;
                        renderImageGrid(images);
                        loadCategories();
                    })
                    .catch(error => {
                        console.error('Error refreshing images:', error);
                        
                        const imageGrid = document.getElementById('imageGrid');
                        imageGrid.innerHTML = `<div class="error-message">Error loading images: ${error.message}</div>`;
                    });
            }
            
            // Public API
            return {
                init: function() {
                    // Attach event listeners
                    document.getElementById('imageSearchBtn').addEventListener('click', search);
                    document.getElementById('imageSearchInput').addEventListener('keypress', e => {
                        if (e.key === 'Enter') search();
                    });
                    document.getElementById('prevImagesPage').addEventListener('click', () => {
                        if (currentPage > 1) {
                            currentPage--;
                            renderImageGrid(currentImages);
                        }
                    });
                    document.getElementById('nextImagesPage').addEventListener('click', () => {
                        if (currentPage < totalPages) {
                            currentPage++;
                            renderImageGrid(currentImages);
                        }
                    });
                    
                    return this;
                },
                
                open: async function(onSelectCallback) {
                    // Save callback
                    onImageSelectCallback = onSelectCallback;
                    
                    // Reset selection
                    selectedImageUrl = '';
                    selectedImageId = '';
                    
                    // Show modal
                    showModal('imageBrowserModal');
                    
                    // Load images if needed
                    if (currentImages.length === 0) {
                        try {
                            const images = await fetchImages();
                            currentImages = images;
                            renderImageGrid(images);
                            loadCategories();
                        } catch (error) {
                            console.error('Error loading images:', error);
                            
                            const imageGrid = document.getElementById('imageGrid');
                            imageGrid.innerHTML = `<div class="error-message">Error loading images: ${error.message}</div>`;
                        }
                    } else {
                        renderImageGrid(currentImages);
                    }
                },
                
                confirm: function() {
                    if (selectedImageUrl && onImageSelectCallback) {
                        onImageSelectCallback(selectedImageUrl);
                    }
                    
                    closeModal('imageBrowserModal');
                },
                
                uploadImage: async function(file, category = '') {
                    if (!GoogleDriveAPI.isLoggedIn()) {
                        try {
                            await GoogleDriveAPI.login();
                        } catch (error) {
                            throw new Error('Please connect to Google Drive first');
                        }
                    }
                    
                    try {
                        await GoogleDriveAPI.uploadImage(file, category);
                        refresh();
                    } catch (error) {
                        throw error;
                    }
                }
            };
        })();

        /* 
        ==========================================
        SCORES SYSTEM
        ==========================================
        */
        const Scores = (function() {
            // Private variables
            let scores = {
                truefalse: 0,
                matching: 0,
                writing: 0,
                multipleChoice: 0,
                srs: 0,
                flashcard: 0,
                totalCorrect: 0,
                totalAttempts: 0
            };
            
            // Public API
            return {
                init: function() {
                    this.updateScoreDisplays();
                    return this;
                },
                
                get: function(exerciseType) {
                    return scores[exerciseType] || 0;
                },
                
                getAll: function() {
                    return { ...scores };
                },
                
                setAll: function(newScores) {
                    scores = { ...newScores };
                    this.updateScoreDisplays();
                },
                
                addScore: function(exerciseType, points) {
                    scores[exerciseType] = (scores[exerciseType] || 0) + points;
                    this.updateScoreDisplays();
                },
                
                recordAttempt: function(correct) {
                    scores.totalAttempts++;
                    
                    if (correct) {
                        scores.totalCorrect++;
                    }
                    
                    this.updateScoreDisplays();
                },
                
                updateScoreDisplays: function() {
                    const totalScore = 
                        scores.truefalse + 
                        scores.matching + 
                        scores.writing + 
                        scores.multipleChoice + 
                        scores.srs + 
                        scores.flashcard;
                    
                    // Update total score displays
                    document.getElementById('totalScore').textContent = totalScore;
                    document.getElementById('progressTotalScore').textContent = totalScore;
                    
                    // Update correct answers
                    document.getElementById('correctAnswers').textContent = scores.totalCorrect;
                    document.getElementById('progressCorrectAnswers').textContent = scores.totalCorrect;
                    
                    // Update total attempts
                    document.getElementById('totalAttempts').textContent = scores.totalAttempts;
                    
                    // Update accuracy
                    const accuracy = scores.totalAttempts > 0 
                        ? Math.round((scores.totalCorrect / scores.totalAttempts) * 100) 
                        : 0;
                    document.getElementById('progressAccuracy').textContent = accuracy + '%';
                    
                    // Update exercise-specific scores
                    if (document.getElementById('tfScore')) 
                        document.getElementById('tfScore').textContent = scores.truefalse;
                    
                    if (document.getElementById('matchingScore')) 
                        document.getElementById('matchingScore').textContent = scores.matching;
                    
                    if (document.getElementById('writingScore')) 
                        document.getElementById('writingScore').textContent = scores.writing;
                    
                    if (document.getElementById('mcScore')) 
                        document.getElementById('mcScore').textContent = scores.multipleChoice;
                    
                    if (document.getElementById('srsScore')) 
                        document.getElementById('srsScore').textContent = scores.srs;
                }
            };
        })();

        /* 
        ==========================================
        IMAGE UTILITIES
        ==========================================
        */
        const ImageUtils = (function() {
            // Configuration
            const maxWidth = 800;
            const maxHeight = 800;
            const maxFileSize = 2 * 1024 * 1024; // 2MB
            const quality = 0.85;
            const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
            
            // Public API
            return {
                validateAndProcessImage: function(file) {
                    return new Promise((resolve, reject) => {
                        if (!file) {
                            reject(new Error('No file selected'));
                            return;
                        }
                        
                        if (!allowedTypes.includes(file.type)) {
                            reject(new Error('Please use JPG, PNG, GIF or WebP image'));
                            return;
                        }
                        
                        if (file.size > maxFileSize) {
                            reject(new Error('Image too large (max 2MB)'));
                            return;
                        }
                        
                        const img = new Image();
                        
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            let { width, height } = img;
                            
                            if (width > maxWidth) {
                                height *= maxWidth / width;
                                width = maxWidth;
                            }
                            
                            if (height > maxHeight) {
                                width *= maxHeight / height;
                                height = maxHeight;
                            }
                            
                            canvas.width = width;
                            canvas.height = height;
                            
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            resolve(canvas.toDataURL('image/jpeg', quality));
                            URL.revokeObjectURL(img.src);
                        };
                        
                        img.onerror = () => {
                            URL.revokeObjectURL(img.src);
                            reject(new Error('Failed to load image'));
                        };
                        
                        img.src = URL.createObjectURL(file);
                    });
                },
                
                previewImage: function(inputElement, previewElement) {
                    if (!inputElement.files || !inputElement.files[0]) {
                        previewElement.style.display = 'none';
                        return;
                    }
                    
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        previewElement.src = e.target.result;
                        previewElement.style.display = 'block';
                    };
                    
                    reader.readAsDataURL(inputElement.files[0]);
                }
            };
        })();

        /* 
        ==========================================
        TOOLTIPS SYSTEM
        ==========================================
        */
        const TooltipSystem = (function() {
            // Private variables
            const tooltips = {
                addWord: {
                    title: 'Add Your First Word',
                    content: 'Click here to start adding vocabulary words to learn.',
                    position: 'bottom',
                    target: 'addWordBtn',
                    condition: () => FlashMastaApp.getVocabulary().length === 0
                },
                
                exercise: {
                    title: 'Start Practicing',
                    content: 'Try different exercise types to practice your vocabulary.',
                    position: 'bottom',
                    target: 'practice-tab',
                    condition: () => FlashMastaApp.getVocabulary().length > 0 && Scores.getAll().totalAttempts === 0
                },
                
                googleDrive: {
                    title: 'Google Drive Integration',
                    content: 'You can save your vocabulary to Google Drive for access from any device.',
                    position: 'bottom',
                    target: 'settings-tab',
                    condition: () => FlashMastaApp.getVocabulary().length >= 5 && !localStorage.getItem('tooltips_googleDrive_seen')
                }
            };
            
            // Private methods
            function createTooltip(id, options) {
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.id = `tooltip_${id}`;
                tooltip.dataset.position = options.position || 'bottom';
                
                const arrow = document.createElement('div');
                arrow.className = 'tooltip-arrow';
                
                const content = document.createElement('div');
                content.className = 'tooltip-content';
                
                const title = document.createElement('h4');
                title.className = 'tooltip-title';
                title.textContent = options.title;
                
                const text = document.createElement('p');
                text.textContent = options.content;
                
                const button = document.createElement('button');
                button.className = 'btn small';
                button.textContent = 'Got it!';
                button.onclick = function() {
                    dismissTooltip(id);
                };
                
                content.appendChild(title);
                content.appendChild(text);
                content.appendChild(button);
                
                tooltip.appendChild(arrow);
                tooltip.appendChild(content);
                
                return tooltip;
            }
            
            function positionTooltip(tooltip, targetElement) {
                const position = tooltip.dataset.position;
                const targetRect = targetElement.getBoundingClientRect();
                const tooltipRect = tooltip.getBoundingClientRect();
                
                let top, left;
                
                switch (position) {
                    case 'top':
                        top = targetRect.top - tooltipRect.height - 10;
                        left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);
                        break;
                    case 'bottom':
                        top = targetRect.bottom + 10;
                        left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);
                        break;
                    case 'left':
                        top = targetRect.top + (targetRect.height / 2) - (tooltipRect.height / 2);
                        left = targetRect.left - tooltipRect.width - 10;
                        break;
                    case 'right':
                        top = targetRect.top + (targetRect.height / 2) - (tooltipRect.height / 2);
                        left = targetRect.right + 10;
                        break;
                }
                
                // Ensure tooltip is within viewport
                if (left < 10) left = 10;
                if (left + tooltipRect.width > window.innerWidth - 10) {
                    left = window.innerWidth - tooltipRect.width - 10;
                }
                
                if (top < 10) top = 10;
                if (top + tooltipRect.height > window.innerHeight - 10) {
                    top = window.innerHeight - tooltipRect.height - 10;
                }
                
                tooltip.style.top = `${top}px`;
                tooltip.style.left = `${left}px`;
            }
            
            function dismissTooltip(id) {
                const tooltip = document.getElementById(`tooltip_${id}`);
                
                if (tooltip) {
                    tooltip.remove();
                }
                
                localStorage.setItem(`tooltips_${id}_seen`, 'true');
            }
            
            // Public API
            return {
                init: function() {
                    setTimeout(() => this.showTooltips(), 2000);
                    return this;
                },
                
                showTooltips: function() {
                    const container = document.getElementById('tooltipContainer');
                    container.innerHTML = '';
                    
                    Object.entries(tooltips).forEach(([id, options]) => {
                        // Check if tooltip should be shown
                        if (localStorage.getItem(`tooltips_${id}_seen`)) {
                            return;
                        }
                        
                        if (options.condition && !options.condition()) {
                            return;
                        }
                        
                        const targetElement = document.getElementById(options.target);
                        
                        if (!targetElement) {
                            return;
                        }
                        
                        const tooltip = createTooltip(id, options);
                        container.appendChild(tooltip);
                        
                        // Position tooltip after it's added to DOM
                        setTimeout(() => positionTooltip(tooltip, targetElement), 0);
                        
                        // Highlight target element
                        targetElement.style.position = 'relative';
                        targetElement.style.zIndex = '99';
                        targetElement.style.boxShadow = '0 0 0 4px var(--primary-light)';
                    });
                },
                
                dismissTooltip: function(id) {
                    dismissTooltip(id);
                }
            };
        })();

        /* 
        ==========================================
        ONBOARDING SYSTEM
        ==========================================
        */
        const OnboardingSystem = (function() {
            // Private variables
            let currentStep = 1;
            const totalSteps = 5;
            
            // Private methods
            function goToStep(step) {
                // Hide current step
                document.querySelector(`.onboarding-step[data-step="${currentStep}"]`).classList.remove('active');
                document.querySelector(`.progress-dot[data-step="${currentStep}"]`).classList.remove('active');
                
                // Show new step
                currentStep = step;
                document.querySelector(`.onboarding-step[data-step="${currentStep}"]`).classList.add('active');
                document.querySelector(`.progress-dot[data-step="${currentStep}"]`).classList.add('active');
                
                // Update buttons
                document.getElementById('onboardingPrevBtn').disabled = currentStep === 1;
                
                if (currentStep === totalSteps) {
                    document.getElementById('onboardingNextBtn').textContent = 'Finish';
                } else {
                    document.getElementById('onboardingNextBtn').textContent = 'Next';
                }
            }
            
            // Public API
            return {
                init: function() {
                    // Check if this is the first time using the app
                    const hasCompletedOnboarding = localStorage.getItem('flashmasta_onboarding_completed');
                    
                    if (!hasCompletedOnboarding) {
                        this.showOnboarding();
                    }
                    
                    return this;
                },
                
                showOnboarding: function() {
                    showModal('onboardingModal');
                    
                    // Reset to first step
                    currentStep = 1;
                    goToStep(currentStep);
                    
                    // Add event listeners
                    document.getElementById('onboardingNextBtn').addEventListener('click', () => {
                        if (currentStep < totalSteps) {
                            goToStep(currentStep + 1);
                        } else {
                            this.completeOnboarding();
                        }
                    });
                    
                    document.getElementById('onboardingPrevBtn').addEventListener('click', () => {
                        if (currentStep > 1) {
                            goToStep(currentStep - 1);
                        }
                    });
                    
                    document.getElementById('onboardingSkipBtn').addEventListener('click', () => {
                        this.completeOnboarding();
                    });
                    
                    document.getElementById('startAddingWordsBtn').addEventListener('click', () => {
                        this.completeOnboarding();
                        showAddWordModal();
                    });
                    
                    // Allow clicking dots to navigate
                    document.querySelectorAll('.progress-dot').forEach(dot => {
                        dot.addEventListener('click', () => {
                            goToStep(parseInt(dot.dataset.step));
                        });
                    });
                },
                
                completeOnboarding: function() {
                    closeModal('onboardingModal');
                    localStorage.setItem('flashmasta_onboarding_completed', 'true');
                }
            };
        })();

        /* 
        ==========================================
        EXERCISE FUNCTIONS
        ==========================================
        */
        let currentExercise = null;
        let selectedPolish = null;
        let selectedEnglish = null;

        function hideAllExercises() {
            document.querySelectorAll('.exercise').forEach(el => {
                el.style.display = 'none';
            });
        }
        
        function hideExercise(id) {
            document.getElementById(id).style.display = 'none';
        }
        
        function generateTrueFalse() {
            if (FlashMastaApp.getVocabulary().length < 2) {
                alert('Add at least 2 words to start exercises!');
                return;
            }
            
            hideAllExercises();
            
            document.getElementById('trueFalseExercise').style.display = 'block';
            
            const vocabulary = FlashMastaApp.getVocabulary();
            const wordIndex = Math.floor(Math.random() * vocabulary.length);
            const isTrue = Math.random() < 0.5;
            const word = vocabulary[wordIndex];
            
            let englishShow = word.english;
            
            if (!isTrue) {
                let otherWord;
                do {
                    otherWord = vocabulary[Math.floor(Math.random() * vocabulary.length)];
                } while (otherWord === word);
                
                englishShow = otherWord.english;
            }
            
            currentExercise = { correct: isTrue, original: word };
            
            document.getElementById('tfPolish').textContent = word.polish;
            document.getElementById('tfEnglish').textContent = englishShow;
            
            if (word.imageUrl) {
                document.getElementById('tfImage').src = word.imageUrl;
                document.getElementById('tfImage').style.display = 'block';
            } else {
                document.getElementById('tfImage').style.display = 'none';
            }
            
            document.getElementById('tfResult').textContent = '';
            
            AchievementSystem.recordExerciseAttempt('true-false');
        }
        
        function checkTrueFalse(answer) {
            Scores.recordAttempt();
            
            const result = answer === currentExercise.correct;
            const resultElement = document.getElementById('tfResult');
            
            if (result) {
                Scores.addScore('truefalse', AppConfig.exercises.defaultExerciseScore);
                resultElement.textContent = `Correct! +${AppConfig.exercises.defaultExerciseScore} points`;
                resultElement.className = 'result-message success';
            } else {
                Scores.addScore('truefalse', -AppConfig.exercises.wrongAnswerPenalty);
                resultElement.textContent = `Wrong! -${AppConfig.exercises.wrongAnswerPenalty} points`;
                resultElement.className = 'result-message error';
            }
            
            setTimeout(generateTrueFalse, 2000);
        }
        
        function generateMultipleChoice() {
            if (FlashMastaApp.getVocabulary().length < AppConfig.exercises.minWordsForMultipleChoice) {
                alert(`Add at least ${AppConfig.exercises.minWordsForMultipleChoice} words for multiple choice exercise!`);
                return;
            }
            
            hideAllExercises();
            
            document.getElementById('multipleChoiceExercise').style.display = 'block';
            
            const vocabulary = FlashMastaApp.getVocabulary();
            const word = vocabulary[Math.floor(Math.random() * vocabulary.length)];
            
            currentExercise = { word };
            
            document.getElementById('mcPolish').textContent = word.polish;
            
            let options = [word.english];
            
            while (options.length < 4) {
                const randomOption = vocabulary[Math.floor(Math.random() * vocabulary.length)].english;
                
                if (!options.includes(randomOption)) {
                    options.push(randomOption);
                }
            }
            
            // Shuffle options
            options = options.sort(() => Math.random() - 0.5);
            
            const optionsDiv = document.getElementById('mcOptions');
            optionsDiv.innerHTML = '';
            
            options.forEach(option => {
                const btn = document.createElement('button');
                btn.textContent = option;
                btn.onclick = () => checkMultipleChoice(option);
                optionsDiv.appendChild(btn);
            });
            
            document.getElementById('mcResult').textContent = '';
            
            AchievementSystem.recordExerciseAttempt('multiple-choice');
        }
        
        function checkMultipleChoice(selected) {
            Scores.recordAttempt();
            
            const resultElement = document.getElementById('mcResult');
            const success = selected === currentExercise.word.english;
            
            if (success) {
                Scores.addScore('multipleChoice', AppConfig.exercises.defaultExerciseScore);
                resultElement.textContent = `Correct! +${AppConfig.exercises.defaultExerciseScore} points`;
                resultElement.className = 'result-message success';
            } else {
                Scores.addScore('multipleChoice', -AppConfig.exercises.wrongAnswerPenalty);
                resultElement.textContent = `Wrong! The correct answer is: ${currentExercise.word.english}. -${AppConfig.exercises.wrongAnswerPenalty} points`;
                resultElement.className = 'result-message error';
            }
            
            // Record attempt in SRS system if the word exists in vocabulary
            // This is for stand-alone practice, not SRS exercise itself
            const vocabulary = FlashMastaApp.getVocabulary();
            const wordIndex = vocabulary.findIndex(w => w.english === currentExercise.word.english);
            
            if (wordIndex >= 0) {
                SRSSystem.recordAttempt(vocabulary[wordIndex], 'multipleChoice', success);
            }
            
            setTimeout(generateMultipleChoice, 2000);
        }
        
        function generateSRS() {
            const vocabulary = FlashMastaApp.getVocabulary();
            
            if (vocabulary.length < 1) {
                alert('Add at least 1 word for SRS exercise!');
                return;
            }
            
            // Get words due for review, prioritizing non-mastered words
            const dueWords = SRSSystem.getDueWords()
                .filter(word => word.difficulty !== 'mastered');
            
            if (dueWords.length === 0) {
                // If no words are due, use any non-mastered word
                const availableWords = vocabulary.filter(word => word.difficulty !== 'mastered');
                
                if (availableWords.length === 0) {
                    alert('Congratulations! All words have been mastered!');
                    return;
                }
                
                practiceWord(vocabulary.indexOf(availableWords[Math.floor(Math.random() * availableWords.length)]));
                return;
            }
            
            hideAllExercises();
            
            document.getElementById('srsExercise').style.display = 'block';
            
            const word = dueWords[Math.floor(Math.random() * dueWords.length)];
            
            currentExercise = { word };
            
            document.getElementById('srsPolish').textContent = word.polish;
            
            const useMultipleChoice = SRSSystem.shouldUseMultipleChoice(word);
            
            document.getElementById('srsMultipleChoice').style.display = useMultipleChoice ? 'block' : 'none';
            document.getElementById('srsWriting').style.display = useMultipleChoice ? 'none' : 'block';
            
            if (useMultipleChoice) {
                let options = [word.english];
                
                while (options.length < 4) {
                    const randomWord = vocabulary[Math.floor(Math.random() * vocabulary.length)];
                    
                    if (!options.includes(randomWord.english)) {
                        options.push(randomWord.english);
                    }
                }
                
                options = options.sort(() => Math.random() - 0.5);
                
                const optionsDiv = document.getElementById('srsOptions');
                optionsDiv.innerHTML = '';
                
                options.forEach(option => {
                    const btn = document.createElement('button');
                    btn.textContent = option;
                    btn.onclick = () => checkSRSMultipleChoice(option);
                    optionsDiv.appendChild(btn);
                });
            } else {
                document.getElementById('srsAnswer').value = '';
                
                // Focus input
                setTimeout(() => {
                    document.getElementById('srsAnswer').focus();
                }, 100);
                
                // Add enter key listener
                document.getElementById('srsAnswer').onkeypress = function(e) {
                    if (e.key === 'Enter') {
                        checkSRS();
                    }
                };
            }
            
            document.getElementById('srsResult').textContent = '';
            
            SRSSystem.updateProgressDisplay(word, 'srs');
            
            AchievementSystem.recordExerciseAttempt('srs');
        }
        
        function checkSRSMultipleChoice(selected) {
            Scores.recordAttempt();
            
            const resultElement = document.getElementById('srsResult');
            const success = selected === currentExercise.word.english;
            
            if (success) {
                Scores.addScore('srs', AppConfig.exercises.defaultExerciseScore);
                resultElement.textContent = `Correct! +${AppConfig.exercises.defaultExerciseScore} points`;
                resultElement.className = 'result-message success';
            } else {
                Scores.addScore('srs', -AppConfig.exercises.wrongAnswerPenalty);
                resultElement.textContent = `Wrong! The correct answer is: ${currentExercise.word.english}. -${AppConfig.exercises.wrongAnswerPenalty} points`;
                resultElement.className = 'result-message error';
            }
            
            SRSSystem.recordAttempt(currentExercise.word, 'multipleChoice', success);
            SRSSystem.updateProgressDisplay(currentExercise.word, 'srs');
            
            // Update vocabulary UI since word difficulty may have changed
            FlashMastaApp.updateVocabularyDisplay();
            
            setTimeout(generateSRS, 2000);
        }
        
        function checkSRS() {
            Scores.recordAttempt();
            
            const answer = document.getElementById('srsAnswer').value.trim().toLowerCase();
            const correct = currentExercise.word.english.toLowerCase();
            const resultElement = document.getElementById('srsResult');
            const success = answer === correct;
            
            if (success) {
                Scores.addScore('srs', 15);
                resultElement.textContent = 'Correct! +15 points';
                resultElement.className = 'result-message success';
                
                // Record consecutive writing successes for achievements
                const counters = SRSSystem.getSuccessCounters()[currentExercise.word.english];
                if (counters) {
                    AchievementSystem.recordWritingSuccess(counters.consecutive + 1);
                }
            } else {
                Scores.addScore('srs', -AppConfig.exercises.wrongAnswerPenalty);
                resultElement.textContent = `Wrong! The correct answer is: ${correct}. -${AppConfig.exercises.wrongAnswerPenalty} points`;
                resultElement.className = 'result-message error';
                
                // Reset consecutive writing successes for achievements
                AchievementSystem.recordWritingSuccess(0);
            }
            
            SRSSystem.recordAttempt(currentExercise.word, 'writing', success);
            SRSSystem.updateProgressDisplay(currentExercise.word, 'srs');
            
            // Update vocabulary UI since word difficulty may have changed
            FlashMastaApp.updateVocabularyDisplay();
            
            setTimeout(generateSRS, 2000);
        }
        
        function generateFlashcard() {
            const vocabulary = FlashMastaApp.getVocabulary();
            
            if (vocabulary.length < 1) {
                alert('Add at least 1 word for flashcard mode!');
                return;
            }
            
            hideAllExercises();
            
            document.getElementById('flashcardExercise').style.display = 'block';
            
            const word = vocabulary[Math.floor(Math.random() * vocabulary.length)];
            
            if (!word.difficulty) {
                word.difficulty = 'medium';
            }
            
            currentExercise = { word };
            
            const flashcard = document.querySelector('.flashcard');
            const flashcardFront = document.getElementById('flashcardFront');
            const flashcardBack = document.getElementById('flashcardBack');
            
            flashcardFront.innerHTML = `<strong>${word.polish}</strong>`;
            
            if (word.imageUrl) {
                flashcardFront.innerHTML += `<br><img src="${word.imageUrl}" style="max-width:100px; margin-top:10px;">`;
            }
            
            flashcardBack.innerHTML = `<strong>${word.english}</strong>`;
            
            flashcard.classList.remove('flipped');
            flashcard.setAttribute('data-difficulty', word.difficulty);
            
            document.querySelectorAll('.difficulty-tag').forEach(tag => {
                tag.classList.toggle('selected', tag.classList.contains(word.difficulty));
            });
            
            SRSSystem.updateProgressDisplay(word, 'flashcard');
            
            AchievementSystem.recordExerciseAttempt('flashcard');
        }
        
        function flipFlashcard() {
            const flashcard = document.querySelector('.flashcard');
            flashcard.classList.toggle('flipped');
        }
        
        function tagWord(difficulty) {
            if (!currentExercise || !currentExercise.word) return;
            
            const vocabulary = FlashMastaApp.getVocabulary();
            const wordIndex = vocabulary.findIndex(w => w.english === currentExercise.word.english);
            
            if (wordIndex >= 0) {
                const word = vocabulary[wordIndex];
                const oldDifficulty = word.difficulty;
                
                word.difficulty = difficulty;
                
                if (oldDifficulty !== difficulty) {
                    SRSSystem.getSuccessCounters()[word.english] = {
                        multipleChoice: 0,
                        writing: 0,
                        consecutive: 0
                    };
                    
                    // Update next review date based on new difficulty
                    word.nextReview = Date.now();
                }
                
                // Update UI
                document.querySelectorAll('.difficulty-tag').forEach(tag => {
                    tag.classList.toggle('selected', tag.classList.contains(difficulty));
                });
                
                SRSSystem.updateProgressDisplay(word, 'flashcard');
                FlashMastaApp.updateVocabularyDisplay();
            }
            
            setTimeout(generateFlashcard, 500);
        }
        
        function generateMatching() {
            const vocabulary = FlashMastaApp.getVocabulary();
            
            if (vocabulary.length < AppConfig.exercises.minWordsForMatching) {
                alert(`Add at least ${AppConfig.exercises.minWordsForMatching} words to start matching exercise!`);
                return;
            }
            
            hideAllExercises();
            
            document.getElementById('matchingExercise').style.display = 'block';
            
            const words = [...vocabulary]
                .sort(() => Math.random() - 0.5)
                .slice(0, Math.min(5, vocabulary.length));
            
            const polishDiv = document.getElementById('polishWords');
            const englishDiv = document.getElementById('englishWords');
            
            polishDiv.innerHTML = '';
            englishDiv.innerHTML = '';
            
            words.forEach((word, index) => {
                const polishWord = document.createElement('div');
                polishWord.className = 'word-pair';
                polishWord.textContent = word.polish;
                polishWord.dataset.index = index;
                polishWord.onclick = () => selectWord(polishWord, 'polish');
                
                polishDiv.appendChild(polishWord);
                
                const englishWord = document.createElement('div');
                englishWord.className = 'word-pair';
                englishWord.textContent = word.english;
                englishWord.dataset.index = index;
                englishWord.onclick = () => selectWord(englishWord, 'english');
                
                englishDiv.appendChild(englishWord);
            });
            
            // Shuffle English words
            for (let i = englishDiv.children.length; i >= 0; i--) {
                englishDiv.appendChild(englishDiv.children[Math.random() * i | 0]);
            }
            
            currentExercise = { words };
            
            document.getElementById('matchingResult').textContent = '';
            
            // Reset selections
            selectedPolish = null;
            selectedEnglish = null;
            
            AchievementSystem.recordExerciseAttempt('matching');
        }
        
        function selectWord(element, type) {
            if (type === 'polish') {
                if (selectedPolish) selectedPolish.classList.remove('selected');
                selectedPolish = element;
            } else {
                if (selectedEnglish) selectedEnglish.classList.remove('selected');
                selectedEnglish = element;
            }
            
            element.classList.add('selected');
            
            if (selectedPolish && selectedEnglish) {
                Scores.recordAttempt();
                
                if (selectedPolish.dataset.index === selectedEnglish.dataset.index) {
                    Scores.addScore('matching', 5);
                    selectedPolish.style.visibility = 'hidden';
                    selectedEnglish.style.visibility = 'hidden';
                    
                    document.getElementById('matchingResult').textContent = 'Match found! +5 points';
                    document.getElementById('matchingResult').className = 'result-message success';
                } else {
                    Scores.addScore('matching', -2);
                    
                    document.getElementById('matchingResult').textContent = 'Wrong match! -2 points';
                    document.getElementById('matchingResult').className = 'result-message error';
                }
                
                selectedPolish.classList.remove('selected');
                selectedEnglish.classList.remove('selected');
                selectedPolish = null;
                selectedEnglish = null;
                
                const visibleWords = Array.from(document.getElementById('polishWords').children)
                    .filter(el => el.style.visibility !== 'hidden');
                
                if (visibleWords.length === 0) {
                    setTimeout(() => {
                        document.getElementById('matchingResult').textContent = 'Congratulations! All matches found! +10 bonus points';
                        Scores.addScore('matching', 10);
                        
                        setTimeout(generateMatching, 2000);
                    }, 500);
                }
            }
        }
        
        function generateWriting() {
            const vocabulary = FlashMastaApp.getVocabulary();
            
            if (vocabulary.length < 1) {
                alert('Add at least 1 word to start writing exercise!');
                return;
            }
            
            hideAllExercises();
            
            document.getElementById('writingExercise').style.display = 'block';
            
            const word = vocabulary[Math.floor(Math.random() * vocabulary.length)];
            
            currentExercise = { word };
            
            document.getElementById('writePolish').textContent = word.polish;
            document.getElementById('writeAnswer').value = '';
            document.getElementById('writeResult').textContent = '';
            
            if (word.imageUrl) {
                document.getElementById('writeImage').src = word.imageUrl;
                document.getElementById('writeImage').style.display = 'block';
            } else {
                document.getElementById('writeImage').style.display = 'none';
            }
            
            // Focus input
            setTimeout(() => {
                document.getElementById('writeAnswer').focus();
            }, 100);
            
            // Add enter key listener
            document.getElementById('writeAnswer').onkeypress = function(e) {
                if (e.key === 'Enter') {
                    checkWriting();
                }
            };
            
            AchievementSystem.recordExerciseAttempt('writing');
        }
        
        function checkWriting() {
            Scores.recordAttempt();
            
            const answer = document.getElementById('writeAnswer').value.trim().toLowerCase();
            const correct = currentExercise.word.english.toLowerCase();
            const resultElement = document.getElementById('writeResult');
            const success = answer === correct;
            
            if (success) {
                Scores.addScore('writing', 15);
                resultElement.textContent = 'Correct! +15 points';
                resultElement.className = 'result-message success';
                
                // Record attempt in SRS system
                const vocabulary = FlashMastaApp.getVocabulary();
                const wordIndex = vocabulary.findIndex(w => w.english === currentExercise.word.english);
                
                if (wordIndex >= 0) {
                    SRSSystem.recordAttempt(vocabulary[wordIndex], 'writing', true);
                    
                    // Get updated consecutive success count for achievements
                    const counters = SRSSystem.getSuccessCounters()[currentExercise.word.english];
                    if (counters) {
                        AchievementSystem.recordWritingSuccess(counters.consecutive);
                    }
                    
                    // Update vocabulary UI since word difficulty may have changed
                    FlashMastaApp.updateVocabularyDisplay();
                }
                
                setTimeout(generateWriting, 2000);
            } else {
                Scores.addScore('writing', -7);
                resultElement.textContent = `Wrong! The correct answer is: ${correct}. -7 points`;
                resultElement.className = 'result-message error';
                
                // Record attempt in SRS system
                const vocabulary = FlashMastaApp.getVocabulary();
                const wordIndex = vocabulary.findIndex(w => w.english === currentExercise.word.english);
                
                if (wordIndex >= 0) {
                    SRSSystem.recordAttempt(vocabulary[wordIndex], 'writing', false);
                    
                    // Reset consecutive writing successes for achievements
                    AchievementSystem.recordWritingSuccess(0);
                    
                    // Update vocabulary UI since word difficulty may have changed
                    FlashMastaApp.updateVocabularyDisplay();
                }
            }
        }
        
        function practiceWord(index) {
            const vocabulary = FlashMastaApp.getVocabulary();
            
            if (index < 0 || index >= vocabulary.length) {
                return;
            }
            
            const word = vocabulary[index];
            
            // Choose appropriate exercise based on word difficulty
            switch (word.difficulty) {
                case 'hard':
                case 'medium':
                    // For harder words, use multiple choice
                    hideAllExercises();
                    document.getElementById('multipleChoiceExercise').style.display = 'block';
                    
                    currentExercise = { word };
                    
                    document.getElementById('mcPolish').textContent = word.polish;
                    
                    let options = [word.english];
                    
                    while (options.length < 4) {
                        const randomOption = vocabulary[Math.floor(Math.random() * vocabulary.length)].english;
                        
                        if (!options.includes(randomOption)) {
                            options.push(randomOption);
                        }
                    }
                    
                    options = options.sort(() => Math.random() - 0.5);
                    
                    const optionsDiv = document.getElementById('mcOptions');
                    optionsDiv.innerHTML = '';
                    
                    options.forEach(option => {
                        const btn = document.createElement('button');
                        btn.textContent = option;
                        btn.onclick = () => checkMultipleChoice(option);
                        optionsDiv.appendChild(btn);
                    });
                    
                    document.getElementById('mcResult').textContent = '';
                    break;
                    
                case 'easy':
                case 'learnt':
                case 'mastered':
                    // For easier words, use writing
                    hideAllExercises();
                    document.getElementById('writingExercise').style.display = 'block';
                    
                    currentExercise = { word };
                    
                    document.getElementById('writePolish').textContent = word.polish;
                    document.getElementById('writeAnswer').value = '';
                    document.getElementById('writeResult').textContent = '';
                    
                    if (word.imageUrl) {
                        document.getElementById('writeImage').src = word.imageUrl;
                        document.getElementById('writeImage').style.display = 'block';
                    } else {
                        document.getElementById('writeImage').style.display = 'none';
                    }
                    
                    // Focus input
                    setTimeout(() => {
                        document.getElementById('writeAnswer').focus();
                    }, 100);
                    
                    // Add enter key listener
                    document.getElementById('writeAnswer').onkeypress = function(e) {
                        if (e.key === 'Enter') {
                            checkWriting();
                        }
                    };
                    break;
            }
        }

        /* 
        ==========================================
        VOCABULARY MANAGEMENT FUNCTIONS
        ==========================================
        */
        function addWord() {
            const english = document.getElementById('englishWord').value.trim();
            const polish = document.getElementById('polishWord').value.trim();
            const imageUrl = document.getElementById('imageUrl').value.trim();
            const localImageInput = document.getElementById('localImage');
            const tags = document.getElementById('wordTags').value.trim();
            
            if (!english || !polish) {
                alert('Please enter both English and Polish words!');
                return;
            }
            
            function finalizeAdd(imageData) {
                try {
                    FlashMastaApp.addWord({
                        english,
                        polish,
                        imageUrl: imageData || imageUrl,
                        tags,
                        difficulty: 'medium',
                        nextReview: Date.now()
                    });
                    
                    clearAddWordInputs();
                    closeModal('addWordModal');
                    alert('Word added successfully!');
                } catch (error) {
                    alert('Error adding word: ' + error.message);
                }
            }
            
            if (localImageInput.files && localImageInput.files[0]) {
                ImageUtils.validateAndProcessImage(localImageInput.files[0])
                    .then(processedImage => {
                        finalizeAdd(processedImage);
                    })
                    .catch(error => {
                        alert(error.message);
                    });
            } else {
                finalizeAdd();
            }
        }
        
        function clearAddWordInputs() {
            document.getElementById('englishWord').value = '';
            document.getElementById('polishWord').value = '';
            document.getElementById('imageUrl').value = '';
            document.getElementById('localImage').value = '';
            document.getElementById('wordTags').value = '';
            document.getElementById('imagePreview').style.display = 'none';
        }
        
        let currentEditIndex = -1;
        
        function editWord(index) {
            currentEditIndex = index;
            
            const vocabulary = FlashMastaApp.getVocabulary();
            const word = vocabulary[index];
            
            document.getElementById('editEnglish').value = word.english;
            document.getElementById('editPolish').value = word.polish;
            document.getElementById('editImageUrl').value = word.imageUrl || '';
            document.getElementById('editTags').value = word.tags || '';
            
            const preview = document.getElementById('editImagePreview');
            
            if (word.imageUrl) {
                preview.src = word.imageUrl;
                preview.style.display = 'block';
            } else {
                preview.style.display = 'none';
            }
            
            showModal('editWordModal');
        }
        
        function saveEdit() {
            if (currentEditIndex === -1) return;
            
            const english = document.getElementById('editEnglish').value.trim();
            const polish = document.getElementById('editPolish').value.trim();
            const imageUrl = document.getElementById('editImageUrl').value.trim();
            const tags = document.getElementById('editTags').value.trim();
            const localImage = document.getElementById('editLocalImage').files[0];
            
            if (!english || !polish) {
                alert('Please enter both English and Polish words!');
                return;
            }
            
            function finalizeEdit(imageData) {
                try {
                    FlashMastaApp.editWord(currentEditIndex, {
                        english,
                        polish,
                        imageUrl: imageData || imageUrl,
                        tags
                    });
                    
                    closeModal('editWordModal');
                    currentEditIndex = -1;
                } catch (error) {
                    alert('Error saving word: ' + error.message);
                }
            }
            
            if (localImage) {
                ImageUtils.validateAndProcessImage(localImage)
                    .then(processedImage => {
                        finalizeEdit(processedImage);
                    })
                    .catch(error => {
                        alert(error.message);
                    });
            } else {
                finalizeEdit();
            }
        }
        
        function deleteWord(index) {
            if (confirm("Are you sure you want to delete this word?")) {
                try {
                    FlashMastaApp.deleteWord(index);
                } catch (error) {
                    alert('Error deleting word: ' + error.message);
                }
            }
        }
        
        function saveToFile() {
            const filename = `flashmasta_vocabulary_${new Date().toISOString().split('T')[0]}.json`;
            
            StorageManager.saveToFile(filename)
                .then(success => {
                    if (success) {
                        alert('Vocabulary saved successfully!');
                    }
                })
                .catch(error => {
                    alert('Error saving vocabulary: ' + error.message);
                });
        }
        
        function loadFromFile(input) {
            StorageManager.loadFromFile(input)
                .then(success => {
                    if (success) {
                        alert('Vocabulary loaded successfully!');
                    }
                })
                .catch(error => {
                    alert('Error loading vocabulary: ' + error.message);
                });
        }
        
        function filterVocabulary() {
            FlashMastaApp.updateVocabList();
        }
        
        function searchVocabulary() {
            FlashMastaApp.updateVocabList();
        }

        /* 
        ==========================================
        MODAL DIALOG FUNCTIONS
        ==========================================
        */
        function showModal(modalId) {
            const modal = document.getElementById(modalId);
            
            if (modal) {
                modal.style.display = 'block';
                
                // For image preview in add/edit word modals
                if (modalId === 'addWordModal') {
                    // Setup image preview for add word
                    const imageUrlInput = document.getElementById('imageUrl');
                    const imagePreview = document.getElementById('imagePreview');
                    
                    imageUrlInput.addEventListener('input', function() {
                        if (this.value.trim()) {
                            imagePreview.src = this.value;
                            imagePreview.style.display = 'block';
                        } else {
                            imagePreview.style.display = 'none';
                        }
                    });
                    
                    const localImageInput = document.getElementById('localImage');
                    
                    localImageInput.addEventListener('change', function() {
                        ImageUtils.previewImage(this, imagePreview);
                    });
                } else if (modalId === 'editWordModal') {
                    // Setup image preview for edit word
                    const imageUrlInput = document.getElementById('editImageUrl');
                    const imagePreview = document.getElementById('editImagePreview');
                    
                    imageUrlInput.addEventListener('input', function() {
                        if (this.value.trim()) {
                            imagePreview.src = this.value;
                            imagePreview.style.display = 'block';
                        } else {
                            imagePreview.style.display = 'none';
                        }
                    });
                    
                    const localImageInput = document.getElementById('editLocalImage');
                    
                    localImageInput.addEventListener('change', function() {
                        ImageUtils.previewImage(this, imagePreview);
                    });
                }
            }
        }
        
        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        function showAddWordModal() {
            clearAddWordInputs();
            showModal('addWordModal');
        }
        
        function showAchievements() {
            // Populate achievements grid
            const grid = document.getElementById('achievementsGrid');
            grid.innerHTML = '';
            
            const achievements = AchievementSystem.getAllAchievements();
            
            // Group achievements by type
            const groupedAchievements = achievements.reduce((acc, achievement) => {
                if (!acc[achievement.type]) acc[achievement.type] = [];
                acc[achievement.type].push(achievement);
                return acc;
            }, {});
            
            // Sort by type and level
            Object.entries(groupedAchievements).forEach(([type, achievements]) => {
                const typeHeading = document.createElement('h3');
                typeHeading.textContent = type.charAt(0).toUpperCase() + type.slice(1) + ' Achievements';
                typeHeading.style.gridColumn = '1 / -1';
                grid.appendChild(typeHeading);
                
                // Sort by level
                achievements
                    .sort((a, b) => a.level - b.level)
                    .forEach(achievement => {
                        const card = document.createElement('div');
                        card.className = `achievement-card ${achievement.achieved ? 'achieved' : ''}`;
                        
                        const progress = achievement.target ?
                            Math.min(100, (achievement.progress / achievement.target) * 100) : 0;
                        
                        card.innerHTML = `
                            <div class="achievement-icon">${achievement.icon}</div>
                            <div class="achievement-title">${achievement.name}</div>
                            <div class="achievement-description">${achievement.description}</div>
                            ${achievement.target ? `
                                <div class="achievement-progress">
                                    <div class="achievement-progress-bar" style="width: ${progress}%"></div>
                                </div>
                                <div class="achievement-progress-text">
                                    ${achievement.progress}/${achievement.target}
                                </div>
                            ` : ''}
                        `;
                        
                        grid.appendChild(card);
                    });
            });
            
            showModal('achievementsModal');
        }
        
        function showAvatarSelector() {
            AvatarSystem.populateAvatarGrid();
            showModal('avatarModal');
        }

        /* 
        ==========================================
        GOOGLE DRIVE INTEGRATION UI
        ==========================================
        */
        function initGoogleDriveSettings() {
            const useGoogleDriveCheckbox = document.getElementById('useGoogleDrive');
            const googleDriveSettings = document.getElementById('googleDriveSettings');
            const googleDriveFiles = document.getElementById('googleDriveFiles');
            
            // Load saved credentials
            const savedClientId = localStorage.getItem('flashmasta_gdrive_client_id') || '';
            const savedApiKey = localStorage.getItem('flashmasta_gdrive_api_key') || '';
            
            document.getElementById('googleClientId').value = savedClientId;
            document.getElementById('googleApiKey').value = savedApiKey;
            
            // Update Google API config
            if (savedClientId && savedApiKey) {
                AppConfig.googleApi.clientId = savedClientId;
                AppConfig.googleApi.apiKey = savedApiKey;
            }
            
            // Setup event listeners
            useGoogleDriveCheckbox.addEventListener('change', function() {
                const useGDrive = this.checked;
                
                googleDriveSettings.style.display = useGDrive ? 'block' : 'none';
                
                if (useGDrive) {
                    AppConfig.storage.useGoogleDrive = true;
                    
                    if (GoogleDriveAPI.isLoggedIn()) {
                        updateGoogleDriveStatus(true);
                        googleDriveFiles.style.display = 'block';
                        loadGoogleDriveFiles();
                    } else {
                        updateGoogleDriveStatus(false);
                    }
                } else {
                    AppConfig.storage.useGoogleDrive = false;
                    googleDriveFiles.style.display = 'none';
                }
            });
            
            document.getElementById('connectGoogleDriveBtn').addEventListener('click', async function() {
                const clientId = document.getElementById('googleClientId').value.trim();
                const apiKey = document.getElementById('googleApiKey').value.trim();
                
                if (!clientId || !apiKey) {
                    alert('Please enter both Client ID and API Key');
                    return;
                }
                
                // Save credentials
                localStorage.setItem('flashmasta_gdrive_client_id', clientId);
                localStorage.setItem('flashmasta_gdrive_api_key', apiKey);
                
                // Update config
                AppConfig.googleApi.clientId = clientId;
                AppConfig.googleApi.apiKey = apiKey;
                
                try {
                    await GoogleDriveAPI.init();
                    await GoogleDriveAPI.login();
                    updateGoogleDriveStatus(true);
                    googleDriveFiles.style.display = 'block';
                    loadGoogleDriveFiles();
                    
                    // Initialize Image Browser
                    await ImageBrowser.init();
                } catch (error) {
                    alert('Failed to connect to Google Drive: ' + error.message);
                    updateGoogleDriveStatus(false);
                }
            });
            
            document.getElementById('disconnectGoogleDriveBtn').addEventListener('click', function() {
                GoogleDriveAPI.logout();
                updateGoogleDriveStatus(false);
                googleDriveFiles.style.display = 'none';
            });
            
            // Check if Google Drive is already connected
            if (GoogleDriveAPI.isLoggedIn()) {
                useGoogleDriveCheckbox.checked = true;
                googleDriveSettings.style.display = 'block';
                updateGoogleDriveStatus(true);
                googleDriveFiles.style.display = 'block';
                loadGoogleDriveFiles();
            }
        }
        
        function updateGoogleDriveStatus(isConnected) {
            const indicator = document.getElementById('driveStatusIndicator');
            const statusText = document.getElementById('driveStatusText');
            const connectBtn = document.getElementById('connectGoogleDriveBtn');
            const disconnectBtn = document.getElementById('disconnectGoogleDriveBtn');
            
            if (isConnected) {
                indicator.classList.add('connected');
                statusText.textContent = 'Connected';
                connectBtn.style.display = 'none';
                disconnectBtn.style.display = 'inline-block';
            } else {
                indicator.classList.remove('connected');
                statusText.textContent = 'Not connected';
                connectBtn.style.display = 'inline-block';
                disconnectBtn.style.display = 'none';
            }
        }
        
        function loadGoogleDriveFiles() {
            const filesList = document.getElementById('driveFilesList');
            filesList.innerHTML = '<p>Loading files...</p>';
            
            GoogleDriveAPI.listFiles()
                .then(files => {
                    if (files.length === 0) {
                        filesList.innerHTML = '<p>No files found in Google Drive</p>';
                        return;
                    }
                    
                    // Filter to only show JSON files
                    const jsonFiles = files.filter(file => 
                        file.name.toLowerCase().endsWith('.json') || 
                        file.mimeType === 'application/json'
                    );
                    
                    if (jsonFiles.length === 0) {
                        filesList.innerHTML = '<p>No vocabulary files found in Google Drive</p>';
                        return;
                    }
                    
                    filesList.innerHTML = '';
                    
                    jsonFiles.forEach(file => {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        
                        const fileInfo = document.createElement('div');
                        fileInfo.className = 'file-info';
                        
                        const fileName = document.createElement('div');
                        fileName.className = 'file-name';
                        fileName.textContent = file.name;
                        
                        const fileDate = document.createElement('div');
                        fileDate.className = 'file-date';
                        
                        if (file.modifiedTime) {
                            const date = new Date(file.modifiedTime);
                            fileDate.textContent = date.toLocaleString();
                        }
                        
                        fileInfo.appendChild(fileName);
                        fileInfo.appendChild(fileDate);
                        
                        const fileActions = document.createElement('div');
                        fileActions.className = 'file-actions';
                        
                        const loadBtn = document.createElement('button');
                        loadBtn.className = 'btn small';
                        loadBtn.textContent = 'Load';
                        loadBtn.onclick = () => loadGoogleDriveFile(file.name);
                        
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'btn small secondary';
                        deleteBtn.textContent = 'Delete';
                        deleteBtn.onclick = () => deleteGoogleDriveFile(file.id, file.name);
                        
                        fileActions.appendChild(loadBtn);
                        fileActions.appendChild(deleteBtn);
                        
                        fileItem.appendChild(fileInfo);
                        fileItem.appendChild(fileActions);
                        
                        filesList.appendChild(fileItem);
                    });
                })
                .catch(error => {
                    filesList.innerHTML = `<p>Error loading files: ${error.message}</p>`;
                });
        }
        
        function loadGoogleDriveFile(filename) {
            if (confirm(`Are you sure you want to load "${filename}"? This will replace your current vocabulary data.`)) {
                StorageManager.loadFromFile(filename)
                    .then(success => {
                        if (success) {
                            alert('Vocabulary loaded successfully!');
                        }
                    })
                    .catch(error => {
                        alert('Error loading file: ' + error.message);
                    });
            }
        }
        
        function deleteGoogleDriveFile(fileId, filename) {
            if (confirm(`Are you sure you want to delete "${filename}"? This cannot be undone.`)) {
                GoogleDriveAPI.deleteFile(fileId)
                    .then(success => {
                        if (success) {
                            alert('File deleted successfully!');
                            loadGoogleDriveFiles();
                        }
                    })
                    .catch(error => {
                        alert('Error deleting file: ' + error.message);
                    });
            }
        }

        /* 
        ==========================================
        THEME CUSTOMIZATION
        ==========================================
        */
        function updateThemeColor(color) {
            document.documentElement.style.setProperty('--primary-color', color);
            
            // Calculate derived colors
            const primaryRGB = hexToRgb(color);
            
            if (primaryRGB) {
                // Darken for primary-dark
                const darkerRGB = {
                    r: Math.max(0, primaryRGB.r - 25),
                    g: Math.max(0, primaryRGB.g - 25),
                    b: Math.max(0, primaryRGB.b - 25)
                };
                
                document.documentElement.style.setProperty(
                    '--primary-dark', 
                    `rgb(${darkerRGB.r}, ${darkerRGB.g}, ${darkerRGB.b})`
                );
                
                // Lighten for primary-light
                const lighterRGB = {
                    r: Math.min(255, primaryRGB.r + 25),
                    g: Math.min(255, primaryRGB.g + 25),
                    b: Math.min(255, primaryRGB.b + 25)
                };
                
                document.documentElement.style.setProperty(
                    '--primary-light', 
                    `rgb(${lighterRGB.r}, ${lighterRGB.g}, ${lighterRGB.b})`
                );
            }
            
            // Save to config
            AppConfig.ui.primaryColor = color;
            
            // Save to localStorage
            localStorage.setItem('flashmasta_theme_color', color);
        }
        
        function updateFontSize(size) {
            const baseSizes = {
                small: {
                    xs: '10px',
                    sm: '12px',
                    md: '14px',
                    lg: '18px',
                    xl: '22px'
                },
                medium: {
                    xs: '12px',
                    sm: '14px',
                    md: '16px',
                    lg: '20px',
                    xl: '24px'
                },
                large: {
                    xs: '14px',
                    sm: '16px',
                    md: '18px',
                    lg: '22px',
                    xl: '28px'
                }
            };
            
            const sizes = baseSizes[size] || baseSizes.medium;
            
            document.documentElement.style.setProperty('--font-size-xs', sizes.xs);
            document.documentElement.style.setProperty('--font-size-sm', sizes.sm);
            document.documentElement.style.setProperty('--font-size-md', sizes.md);
            document.documentElement.style.setProperty('--font-size-lg', sizes.lg);
            document.documentElement.style.setProperty('--font-size-xl', sizes.xl);
            
            // Add body class for font size
            document.body.classList.remove('font-small', 'font-medium', 'font-large');
            document.body.classList.add(`font-${size}`);
            
            // Save to config
            AppConfig.ui.fontSize = size;
            
            // Save to localStorage
            localStorage.setItem('flashmasta_font_size', size);
        }
        
        // Helper to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        function loadThemePreferences() {
            // Load theme color
            const savedColor = localStorage.getItem('flashmasta_theme_color');
            
            if (savedColor) {
                updateThemeColor(savedColor);
                document.getElementById('themeColor').value = savedColor;
            }
            
            // Load font size
            const savedFontSize = localStorage.getItem('flashmasta_font_size');
            
            if (savedFontSize) {
                updateFontSize(savedFontSize);
                document.getElementById('fontSize').value = savedFontSize;
            }
        }

        /* 
        ==========================================
        INITIALIZATION
        ==========================================
        */
        function initTabNavigation() {
            const tabs = document.querySelectorAll('.nav-tab');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active class from all tabs and contents
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab
                    tab.classList.add('active');
                    
                    // Show corresponding content
                    const tabId = tab.dataset.tab;
                    document.getElementById(`${tabId}-tab`).classList.add('active');
                });
            });
        }
        
        function initImageBrowserButtons() {
            // Setup browse image buttons
            document.getElementById('browseImageBtn').addEventListener('click', function() {
                if (!GoogleDriveAPI.isLoggedIn()) {
                    alert('Please connect to Google Drive to use the image browser');
                    return;
                }
                
                ImageBrowser.open(url => {
                    document.getElementById('imageUrl').value = url;
                    const preview = document.getElementById('imagePreview');
                    preview.src = url;
                    preview.style.display = 'block';
                });
            });
            
            document.getElementById('editBrowseImageBtn').addEventListener('click', function() {
                if (!GoogleDriveAPI.isLoggedIn()) {
                    alert('Please connect to Google Drive to use the image browser');
                    return;
                }
                
                ImageBrowser.open(url => {
                    document.getElementById('editImageUrl').value = url;
                    const preview = document.getElementById('editImagePreview');
                    preview.src = url;
                    preview.style.display = 'block';
                });
            });
        }
        
        // Initialize application when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize core modules
            FlashMastaApp.init();
            Scores.init();
            
            // Initialize UI
            initTabNavigation();
            initGoogleDriveSettings();
            loadThemePreferences();
            
            // Initialize storage with user preference
            const useGoogleDrive = document.getElementById('useGoogleDrive').checked;
            StorageManager.init(useGoogleDrive);
            
            // Initialize image browser buttons
            initImageBrowserButtons();
            
            // Try to initialize Google Drive if credentials exist
            const clientId = localStorage.getItem('flashmasta_gdrive_client_id');
            const apiKey = localStorage.getItem('flashmasta_gdrive_api_key');
            
            if (clientId && apiKey) {
                AppConfig.googleApi.clientId = clientId;
                AppConfig.googleApi.apiKey = apiKey;
                
                GoogleDriveAPI.init()
                    .then(() => {
                        if (useGoogleDrive) {
                            return GoogleDriveAPI.login();
                        }
                    })
                    .then(() => {
                        if (GoogleDriveAPI.isLoggedIn()) {
                            updateGoogleDriveStatus(true);
                            document.getElementById('googleDriveFiles').style.display = 'block';
                            loadGoogleDriveFiles();
                            return ImageBrowser.init();
                        }
                    })
                    .catch(error => {
                        console.error('Failed to initialize Google Drive:', error);
                    });
            }
            
            // Try to load data from localStorage
            try {
                const localData = localStorage.getItem('flashmasta_data');
                
                if (localData) {
                    const data = JSON.parse(localData);
                    StorageManager.loadDataFromObject(data);
                }
            } catch (error) {
                console.error('Failed to load data from localStorage:', error);
            }
            
            // Initialize achievement system
            AchievementSystem.init();
            
            // Initialize avatar system
            AvatarSystem.init();
            
            // Initialize onboarding system
            OnboardingSystem.init();
            
            // Initialize tooltip system
            TooltipSystem.init();
            
            // Update interfaces
            FlashMastaApp.updateVocabularyDisplay();
            
            console.log('FlashMasta V10 initialized successfully');
        });

</script>
</body>
</head>
